/* 
 * Knetik Platform API Documentation latest 
 *
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com.
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = com.knetikcloud.Client.SwaggerDateConverter;

namespace com.knetikcloud.Model
{
    /// <summary>
    /// CoreChallengeActivitySettings
    /// </summary>
    [DataContract]
    public partial class CoreChallengeActivitySettings :  IEquatable<CoreChallengeActivitySettings>
    {
        /// <summary>
        /// Restriction for who can host an occurrence. admin disallows regular users, player means the user must also be a player in the occurrence if not admin, non-player means the user has the option to host without being a player. Null to inherit
        /// </summary>
        /// <value>Restriction for who can host an occurrence. admin disallows regular users, player means the user must also be a player in the occurrence if not admin, non-player means the user has the option to host without being a player. Null to inherit</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum HostOptionEnum
        {
            
            /// <summary>
            /// Enum Adminonly for "admin_only"
            /// </summary>
            [EnumMember(Value = "admin_only")]
            Adminonly,
            
            /// <summary>
            /// Enum Player for "player"
            /// </summary>
            [EnumMember(Value = "player")]
            Player,
            
            /// <summary>
            /// Enum Nonplayer for "non_player"
            /// </summary>
            [EnumMember(Value = "non_player")]
            Nonplayer
        }

        /// <summary>
        /// Restriction for who is able to report game end and results. Admin is always able to send results as well. Null to inherit from activity
        /// </summary>
        /// <value>Restriction for who is able to report game end and results. Admin is always able to send results as well. Null to inherit from activity</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ResultsTrustEnum
        {
            
            /// <summary>
            /// Enum None for "none"
            /// </summary>
            [EnumMember(Value = "none")]
            None,
            
            /// <summary>
            /// Enum Host for "host"
            /// </summary>
            [EnumMember(Value = "host")]
            Host,
            
            /// <summary>
            /// Enum All for "all"
            /// </summary>
            [EnumMember(Value = "all")]
            All
        }

        /// <summary>
        /// Restriction for who can host an occurrence. admin disallows regular users, player means the user must also be a player in the occurrence if not admin, non-player means the user has the option to host without being a player. Null to inherit
        /// </summary>
        /// <value>Restriction for who can host an occurrence. admin disallows regular users, player means the user must also be a player in the occurrence if not admin, non-player means the user has the option to host without being a player. Null to inherit</value>
        [DataMember(Name="host_option", EmitDefaultValue=false)]
        public HostOptionEnum? HostOption { get; set; }
        /// <summary>
        /// Restriction for who is able to report game end and results. Admin is always able to send results as well. Null to inherit from activity
        /// </summary>
        /// <value>Restriction for who is able to report game end and results. Admin is always able to send results as well. Null to inherit from activity</value>
        [DataMember(Name="results_trust", EmitDefaultValue=false)]
        public ResultsTrustEnum? ResultsTrust { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="CoreChallengeActivitySettings" /> class.
        /// </summary>
        /// <param name="BootInPlay">Whether the host can boot a user while the status is PLAYING. Null to inherit from activity.</param>
        /// <param name="CustomLaunchAddress">A custom address (url, ip or whatever is needed in your game) that users should connect to to play in this challenge rather than the usual game server. Max length: 255.</param>
        /// <param name="CustomLaunchAddressAllowed">Restriction for whether the host creating an occurrence can specify a custom launch address (such as their own ip address). Will override the challenge&#39;s custom_launch_address if they do. Null to inherit from activity.</param>
        /// <param name="HostOption">Restriction for who can host an occurrence. admin disallows regular users, player means the user must also be a player in the occurrence if not admin, non-player means the user has the option to host without being a player. Null to inherit.</param>
        /// <param name="HostStatusControl">Restriction for whether the host has control of the status once the game launches. If false they can only manage the game before (when setup and open). Max length: 255. Null to inherit from activity.</param>
        /// <param name="JoinInPlay">Whether users can join while the status is PLAYING. Null to inherit from activity.</param>
        /// <param name="LeaveInPlay">Whether users can leave while the status is PLAYING. Null to inherit from activity.</param>
        /// <param name="MaxPlayers">The maximum number of players the game can hold. Null to inherit from activity.</param>
        /// <param name="MinPlayers">The minimum number of players the game can hold. Null to inherit from activity.</param>
        /// <param name="ResultsTrust">Restriction for who is able to report game end and results. Admin is always able to send results as well. Null to inherit from activity.</param>
        public CoreChallengeActivitySettings(bool? BootInPlay = default(bool?), string CustomLaunchAddress = default(string), bool? CustomLaunchAddressAllowed = default(bool?), HostOptionEnum? HostOption = default(HostOptionEnum?), bool? HostStatusControl = default(bool?), bool? JoinInPlay = default(bool?), bool? LeaveInPlay = default(bool?), int? MaxPlayers = default(int?), int? MinPlayers = default(int?), ResultsTrustEnum? ResultsTrust = default(ResultsTrustEnum?))
        {
            this.BootInPlay = BootInPlay;
            this.CustomLaunchAddress = CustomLaunchAddress;
            this.CustomLaunchAddressAllowed = CustomLaunchAddressAllowed;
            this.HostOption = HostOption;
            this.HostStatusControl = HostStatusControl;
            this.JoinInPlay = JoinInPlay;
            this.LeaveInPlay = LeaveInPlay;
            this.MaxPlayers = MaxPlayers;
            this.MinPlayers = MinPlayers;
            this.ResultsTrust = ResultsTrust;
        }
        
        /// <summary>
        /// Whether the host can boot a user while the status is PLAYING. Null to inherit from activity
        /// </summary>
        /// <value>Whether the host can boot a user while the status is PLAYING. Null to inherit from activity</value>
        [DataMember(Name="boot_in_play", EmitDefaultValue=false)]
        public bool? BootInPlay { get; set; }

        /// <summary>
        /// A custom address (url, ip or whatever is needed in your game) that users should connect to to play in this challenge rather than the usual game server. Max length: 255
        /// </summary>
        /// <value>A custom address (url, ip or whatever is needed in your game) that users should connect to to play in this challenge rather than the usual game server. Max length: 255</value>
        [DataMember(Name="custom_launch_address", EmitDefaultValue=false)]
        public string CustomLaunchAddress { get; set; }

        /// <summary>
        /// Restriction for whether the host creating an occurrence can specify a custom launch address (such as their own ip address). Will override the challenge&#39;s custom_launch_address if they do. Null to inherit from activity
        /// </summary>
        /// <value>Restriction for whether the host creating an occurrence can specify a custom launch address (such as their own ip address). Will override the challenge&#39;s custom_launch_address if they do. Null to inherit from activity</value>
        [DataMember(Name="custom_launch_address_allowed", EmitDefaultValue=false)]
        public bool? CustomLaunchAddressAllowed { get; set; }


        /// <summary>
        /// Restriction for whether the host has control of the status once the game launches. If false they can only manage the game before (when setup and open). Max length: 255. Null to inherit from activity
        /// </summary>
        /// <value>Restriction for whether the host has control of the status once the game launches. If false they can only manage the game before (when setup and open). Max length: 255. Null to inherit from activity</value>
        [DataMember(Name="host_status_control", EmitDefaultValue=false)]
        public bool? HostStatusControl { get; set; }

        /// <summary>
        /// Whether users can join while the status is PLAYING. Null to inherit from activity
        /// </summary>
        /// <value>Whether users can join while the status is PLAYING. Null to inherit from activity</value>
        [DataMember(Name="join_in_play", EmitDefaultValue=false)]
        public bool? JoinInPlay { get; set; }

        /// <summary>
        /// Whether users can leave while the status is PLAYING. Null to inherit from activity
        /// </summary>
        /// <value>Whether users can leave while the status is PLAYING. Null to inherit from activity</value>
        [DataMember(Name="leave_in_play", EmitDefaultValue=false)]
        public bool? LeaveInPlay { get; set; }

        /// <summary>
        /// The maximum number of players the game can hold. Null to inherit from activity
        /// </summary>
        /// <value>The maximum number of players the game can hold. Null to inherit from activity</value>
        [DataMember(Name="max_players", EmitDefaultValue=false)]
        public int? MaxPlayers { get; set; }

        /// <summary>
        /// The minimum number of players the game can hold. Null to inherit from activity
        /// </summary>
        /// <value>The minimum number of players the game can hold. Null to inherit from activity</value>
        [DataMember(Name="min_players", EmitDefaultValue=false)]
        public int? MinPlayers { get; set; }


        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class CoreChallengeActivitySettings {\n");
            sb.Append("  BootInPlay: ").Append(BootInPlay).Append("\n");
            sb.Append("  CustomLaunchAddress: ").Append(CustomLaunchAddress).Append("\n");
            sb.Append("  CustomLaunchAddressAllowed: ").Append(CustomLaunchAddressAllowed).Append("\n");
            sb.Append("  HostOption: ").Append(HostOption).Append("\n");
            sb.Append("  HostStatusControl: ").Append(HostStatusControl).Append("\n");
            sb.Append("  JoinInPlay: ").Append(JoinInPlay).Append("\n");
            sb.Append("  LeaveInPlay: ").Append(LeaveInPlay).Append("\n");
            sb.Append("  MaxPlayers: ").Append(MaxPlayers).Append("\n");
            sb.Append("  MinPlayers: ").Append(MinPlayers).Append("\n");
            sb.Append("  ResultsTrust: ").Append(ResultsTrust).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CoreChallengeActivitySettings);
        }

        /// <summary>
        /// Returns true if CoreChallengeActivitySettings instances are equal
        /// </summary>
        /// <param name="input">Instance of CoreChallengeActivitySettings to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CoreChallengeActivitySettings input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.BootInPlay == input.BootInPlay ||
                    (this.BootInPlay != null &&
                    this.BootInPlay.Equals(input.BootInPlay))
                ) && 
                (
                    this.CustomLaunchAddress == input.CustomLaunchAddress ||
                    (this.CustomLaunchAddress != null &&
                    this.CustomLaunchAddress.Equals(input.CustomLaunchAddress))
                ) && 
                (
                    this.CustomLaunchAddressAllowed == input.CustomLaunchAddressAllowed ||
                    (this.CustomLaunchAddressAllowed != null &&
                    this.CustomLaunchAddressAllowed.Equals(input.CustomLaunchAddressAllowed))
                ) && 
                (
                    this.HostOption == input.HostOption ||
                    (this.HostOption != null &&
                    this.HostOption.Equals(input.HostOption))
                ) && 
                (
                    this.HostStatusControl == input.HostStatusControl ||
                    (this.HostStatusControl != null &&
                    this.HostStatusControl.Equals(input.HostStatusControl))
                ) && 
                (
                    this.JoinInPlay == input.JoinInPlay ||
                    (this.JoinInPlay != null &&
                    this.JoinInPlay.Equals(input.JoinInPlay))
                ) && 
                (
                    this.LeaveInPlay == input.LeaveInPlay ||
                    (this.LeaveInPlay != null &&
                    this.LeaveInPlay.Equals(input.LeaveInPlay))
                ) && 
                (
                    this.MaxPlayers == input.MaxPlayers ||
                    (this.MaxPlayers != null &&
                    this.MaxPlayers.Equals(input.MaxPlayers))
                ) && 
                (
                    this.MinPlayers == input.MinPlayers ||
                    (this.MinPlayers != null &&
                    this.MinPlayers.Equals(input.MinPlayers))
                ) && 
                (
                    this.ResultsTrust == input.ResultsTrust ||
                    (this.ResultsTrust != null &&
                    this.ResultsTrust.Equals(input.ResultsTrust))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.BootInPlay != null)
                    hashCode = hashCode * 59 + this.BootInPlay.GetHashCode();
                if (this.CustomLaunchAddress != null)
                    hashCode = hashCode * 59 + this.CustomLaunchAddress.GetHashCode();
                if (this.CustomLaunchAddressAllowed != null)
                    hashCode = hashCode * 59 + this.CustomLaunchAddressAllowed.GetHashCode();
                if (this.HostOption != null)
                    hashCode = hashCode * 59 + this.HostOption.GetHashCode();
                if (this.HostStatusControl != null)
                    hashCode = hashCode * 59 + this.HostStatusControl.GetHashCode();
                if (this.JoinInPlay != null)
                    hashCode = hashCode * 59 + this.JoinInPlay.GetHashCode();
                if (this.LeaveInPlay != null)
                    hashCode = hashCode * 59 + this.LeaveInPlay.GetHashCode();
                if (this.MaxPlayers != null)
                    hashCode = hashCode * 59 + this.MaxPlayers.GetHashCode();
                if (this.MinPlayers != null)
                    hashCode = hashCode * 59 + this.MinPlayers.GetHashCode();
                if (this.ResultsTrust != null)
                    hashCode = hashCode * 59 + this.ResultsTrust.GetHashCode();
                return hashCode;
            }
        }

    }

}
