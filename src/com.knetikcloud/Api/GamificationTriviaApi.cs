/* 
 * Knetik Platform API Documentation latest 
 *
 * This is the spec for the Knetik API.  Use this in conjunction with the documentation found at https://knetikcloud.com
 *
 * OpenAPI spec version: latest 
 * Contact: support@knetik.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using RestSharp;
using com.knetikcloud.Client;
using com.knetikcloud.Model;

namespace com.knetikcloud.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IGamificationTriviaApi : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Add an answer to a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="answer">The new answer (optional)</param>
        /// <returns>AnswerResource</returns>
        AnswerResource AddQuestionAnswers (string questionId, AnswerResource answer = null);

        /// <summary>
        /// Add an answer to a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="answer">The new answer (optional)</param>
        /// <returns>ApiResponse of AnswerResource</returns>
        ApiResponse<AnswerResource> AddQuestionAnswersWithHttpInfo (string questionId, AnswerResource answer = null);
        /// <summary>
        /// Add a tag to a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The new tag (optional)</param>
        /// <returns></returns>
        void AddQuestionTag (string id, string tag = null);

        /// <summary>
        /// Add a tag to a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The new tag (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> AddQuestionTagWithHttpInfo (string id, string tag = null);
        /// <summary>
        /// Add a tag to a batch of questions
        /// </summary>
        /// <remarks>
        /// All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to add (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>int?</returns>
        int? AddTagToQuestionsBatch (string tag = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);

        /// <summary>
        /// Add a tag to a batch of questions
        /// </summary>
        /// <remarks>
        /// All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to add (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>ApiResponse of int?</returns>
        ApiResponse<int?> AddTagToQuestionsBatchWithHttpInfo (string tag = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);
        /// <summary>
        /// Create an import job
        /// </summary>
        /// <remarks>
        /// Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The new import job (optional)</param>
        /// <returns>ImportJobResource</returns>
        ImportJobResource CreateImportJob (ImportJobResource request = null);

        /// <summary>
        /// Create an import job
        /// </summary>
        /// <remarks>
        /// Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The new import job (optional)</param>
        /// <returns>ApiResponse of ImportJobResource</returns>
        ApiResponse<ImportJobResource> CreateImportJobWithHttpInfo (ImportJobResource request = null);
        /// <summary>
        /// Create a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">The new question (optional)</param>
        /// <returns>QuestionResource</returns>
        QuestionResource CreateQuestion (QuestionResource question = null);

        /// <summary>
        /// Create a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">The new question (optional)</param>
        /// <returns>ApiResponse of QuestionResource</returns>
        ApiResponse<QuestionResource> CreateQuestionWithHttpInfo (QuestionResource question = null);
        /// <summary>
        /// Create a question template
        /// </summary>
        /// <remarks>
        /// Question templates define a type of question and the properties they have
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>QuestionTemplateResource</returns>
        QuestionTemplateResource CreateQuestionTemplate (QuestionTemplateResource questionTemplateResource = null);

        /// <summary>
        /// Create a question template
        /// </summary>
        /// <remarks>
        /// Question templates define a type of question and the properties they have
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>ApiResponse of QuestionTemplateResource</returns>
        ApiResponse<QuestionTemplateResource> CreateQuestionTemplateWithHttpInfo (QuestionTemplateResource questionTemplateResource = null);
        /// <summary>
        /// Delete an import job
        /// </summary>
        /// <remarks>
        /// Also deletes all questions that were imported by it
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns></returns>
        void DeleteImportJob (long? id);

        /// <summary>
        /// Delete an import job
        /// </summary>
        /// <remarks>
        /// Also deletes all questions that were imported by it
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteImportJobWithHttpInfo (long? id);
        /// <summary>
        /// Delete a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns></returns>
        void DeleteQuestion (string id);

        /// <summary>
        /// Delete a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteQuestionWithHttpInfo (string id);
        /// <summary>
        /// Remove an answer from a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns></returns>
        void DeleteQuestionAnswers (string questionId, string id);

        /// <summary>
        /// Remove an answer from a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteQuestionAnswersWithHttpInfo (string questionId, string id);
        /// <summary>
        /// Delete a question template
        /// </summary>
        /// <remarks>
        /// If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="cascade">The value needed to delete used templates (optional)</param>
        /// <returns></returns>
        void DeleteQuestionTemplate (string id, string cascade = null);

        /// <summary>
        /// Delete a question template
        /// </summary>
        /// <remarks>
        /// If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="cascade">The value needed to delete used templates (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteQuestionTemplateWithHttpInfo (string id, string cascade = null);
        /// <summary>
        /// Get an import job
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>ImportJobResource</returns>
        ImportJobResource GetImportJob (long? id);

        /// <summary>
        /// Get an import job
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>ApiResponse of ImportJobResource</returns>
        ApiResponse<ImportJobResource> GetImportJobWithHttpInfo (long? id);
        /// <summary>
        /// Get a list of import job
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterVendor">Filter for jobs by vendor id (optional)</param>
        /// <param name="filterCategory">Filter for jobs by category id (optional)</param>
        /// <param name="filterName">Filter for jobs which name *STARTS* with the given string (optional)</param>
        /// <param name="filterStatus">Filter for jobs that are in a specific set of statuses (comma separated) (optional)</param>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>PageResourceImportJobResource</returns>
        PageResourceImportJobResource GetImportJobs (string filterVendor = null, string filterCategory = null, string filterName = null, string filterStatus = null, int? size = null, int? page = null, string order = null);

        /// <summary>
        /// Get a list of import job
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterVendor">Filter for jobs by vendor id (optional)</param>
        /// <param name="filterCategory">Filter for jobs by category id (optional)</param>
        /// <param name="filterName">Filter for jobs which name *STARTS* with the given string (optional)</param>
        /// <param name="filterStatus">Filter for jobs that are in a specific set of statuses (comma separated) (optional)</param>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>ApiResponse of PageResourceImportJobResource</returns>
        ApiResponse<PageResourceImportJobResource> GetImportJobsWithHttpInfo (string filterVendor = null, string filterCategory = null, string filterName = null, string filterStatus = null, int? size = null, int? page = null, string order = null);
        /// <summary>
        /// Get a single question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>QuestionResource</returns>
        QuestionResource GetQuestion (string id);

        /// <summary>
        /// Get a single question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>ApiResponse of QuestionResource</returns>
        ApiResponse<QuestionResource> GetQuestionWithHttpInfo (string id);
        /// <summary>
        /// Get an answer for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>AnswerResource</returns>
        AnswerResource GetQuestionAnswer (string questionId, string id);

        /// <summary>
        /// Get an answer for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>ApiResponse of AnswerResource</returns>
        ApiResponse<AnswerResource> GetQuestionAnswerWithHttpInfo (string questionId, string id);
        /// <summary>
        /// List the answers available for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <returns>List&lt;AnswerResource&gt;</returns>
        List<AnswerResource> GetQuestionAnswers (string questionId);

        /// <summary>
        /// List the answers available for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <returns>ApiResponse of List&lt;AnswerResource&gt;</returns>
        ApiResponse<List<AnswerResource>> GetQuestionAnswersWithHttpInfo (string questionId);
        /// <summary>
        /// List question deltas in ascending order of updated date
        /// </summary>
        /// <remarks>
        /// The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="since">Timestamp in seconds (optional)</param>
        /// <returns>List&lt;DeltaResource&gt;</returns>
        List<DeltaResource> GetQuestionDeltas (long? since = null);

        /// <summary>
        /// List question deltas in ascending order of updated date
        /// </summary>
        /// <remarks>
        /// The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="since">Timestamp in seconds (optional)</param>
        /// <returns>ApiResponse of List&lt;DeltaResource&gt;</returns>
        ApiResponse<List<DeltaResource>> GetQuestionDeltasWithHttpInfo (long? since = null);
        /// <summary>
        /// List the tags for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>List&lt;string&gt;</returns>
        List<string> GetQuestionTags (string id);

        /// <summary>
        /// List the tags for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>ApiResponse of List&lt;string&gt;</returns>
        ApiResponse<List<string>> GetQuestionTagsWithHttpInfo (string id);
        /// <summary>
        /// Get a single question template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <returns>QuestionTemplateResource</returns>
        QuestionTemplateResource GetQuestionTemplate (string id);

        /// <summary>
        /// Get a single question template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <returns>ApiResponse of QuestionTemplateResource</returns>
        ApiResponse<QuestionTemplateResource> GetQuestionTemplateWithHttpInfo (string id);
        /// <summary>
        /// List and search question templates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>PageResourceQuestionTemplateResource</returns>
        PageResourceQuestionTemplateResource GetQuestionTemplates (int? size = null, int? page = null, string order = null);

        /// <summary>
        /// List and search question templates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>ApiResponse of PageResourceQuestionTemplateResource</returns>
        ApiResponse<PageResourceQuestionTemplateResource> GetQuestionTemplatesWithHttpInfo (int? size = null, int? page = null, string order = null);
        /// <summary>
        /// List and search questions
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>PageResourceQuestionResource</returns>
        PageResourceQuestionResource GetQuestions (int? size = null, int? page = null, string order = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterTag = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);

        /// <summary>
        /// List and search questions
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>ApiResponse of PageResourceQuestionResource</returns>
        ApiResponse<PageResourceQuestionResource> GetQuestionsWithHttpInfo (int? size = null, int? page = null, string order = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterTag = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);
        /// <summary>
        /// Count questions based on filters
        /// </summary>
        /// <remarks>
        /// This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <returns>long?</returns>
        long? GetQuestionsCount (string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null);

        /// <summary>
        /// Count questions based on filters
        /// </summary>
        /// <remarks>
        /// This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <returns>ApiResponse of long?</returns>
        ApiResponse<long?> GetQuestionsCountWithHttpInfo (string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null);
        /// <summary>
        /// Start processing an import job
        /// </summary>
        /// <remarks>
        /// Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="publishNow">Whether the new questions should be published live immediately</param>
        /// <returns>ImportJobResource</returns>
        ImportJobResource ProcessImportJob (long? id, bool? publishNow);

        /// <summary>
        /// Start processing an import job
        /// </summary>
        /// <remarks>
        /// Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="publishNow">Whether the new questions should be published live immediately</param>
        /// <returns>ApiResponse of ImportJobResource</returns>
        ApiResponse<ImportJobResource> ProcessImportJobWithHttpInfo (long? id, bool? publishNow);
        /// <summary>
        /// Remove a tag from a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The tag to remove</param>
        /// <returns></returns>
        void RemoveQuestionTag (string id, string tag);

        /// <summary>
        /// Remove a tag from a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The tag to remove</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> RemoveQuestionTagWithHttpInfo (string id, string tag);
        /// <summary>
        /// Remove a tag from a batch of questions
        /// </summary>
        /// <remarks>
        /// ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to remove</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>int?</returns>
        int? RemoveTagToQuestionsBatch (string tag, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);

        /// <summary>
        /// Remove a tag from a batch of questions
        /// </summary>
        /// <remarks>
        /// ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to remove</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>ApiResponse of int?</returns>
        ApiResponse<int?> RemoveTagToQuestionsBatchWithHttpInfo (string tag, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);
        /// <summary>
        /// List and search tags by the beginning of the string
        /// </summary>
        /// <remarks>
        /// For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for tags starting with the given text (optional)</param>
        /// <param name="filterCategory">Filter for tags on questions from a specific category (optional)</param>
        /// <param name="filterImportId">Filter for tags on questions from a specific import job (optional)</param>
        /// <returns>Collectionstring</returns>
        Collectionstring SearchQuestionTags (string filterSearch = null, string filterCategory = null, long? filterImportId = null);

        /// <summary>
        /// List and search tags by the beginning of the string
        /// </summary>
        /// <remarks>
        /// For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for tags starting with the given text (optional)</param>
        /// <param name="filterCategory">Filter for tags on questions from a specific category (optional)</param>
        /// <param name="filterImportId">Filter for tags on questions from a specific import job (optional)</param>
        /// <returns>ApiResponse of Collectionstring</returns>
        ApiResponse<Collectionstring> SearchQuestionTagsWithHttpInfo (string filterSearch = null, string filterCategory = null, long? filterImportId = null);
        /// <summary>
        /// Update an import job
        /// </summary>
        /// <remarks>
        /// Changes should be made before process is started for there to be any effect.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="request">The updated job (optional)</param>
        /// <returns>ImportJobResource</returns>
        ImportJobResource UpdateImportJob (long? id, ImportJobResource request = null);

        /// <summary>
        /// Update an import job
        /// </summary>
        /// <remarks>
        /// Changes should be made before process is started for there to be any effect.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="request">The updated job (optional)</param>
        /// <returns>ApiResponse of ImportJobResource</returns>
        ApiResponse<ImportJobResource> UpdateImportJobWithHttpInfo (long? id, ImportJobResource request = null);
        /// <summary>
        /// Update a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="question">The updated question (optional)</param>
        /// <returns>QuestionResource</returns>
        QuestionResource UpdateQuestion (string id, QuestionResource question = null);

        /// <summary>
        /// Update a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="question">The updated question (optional)</param>
        /// <returns>ApiResponse of QuestionResource</returns>
        ApiResponse<QuestionResource> UpdateQuestionWithHttpInfo (string id, QuestionResource question = null);
        /// <summary>
        /// Update an answer for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <param name="answer">The updated answer (optional)</param>
        /// <returns></returns>
        void UpdateQuestionAnswer (string questionId, string id, AnswerResource answer = null);

        /// <summary>
        /// Update an answer for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <param name="answer">The updated answer (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> UpdateQuestionAnswerWithHttpInfo (string questionId, string id, AnswerResource answer = null);
        /// <summary>
        /// Update a question template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>QuestionTemplateResource</returns>
        QuestionTemplateResource UpdateQuestionTemplate (string id, QuestionTemplateResource questionTemplateResource = null);

        /// <summary>
        /// Update a question template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>ApiResponse of QuestionTemplateResource</returns>
        ApiResponse<QuestionTemplateResource> UpdateQuestionTemplateWithHttpInfo (string id, QuestionTemplateResource questionTemplateResource = null);
        /// <summary>
        /// Bulk update questions
        /// </summary>
        /// <remarks>
        /// Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">New values for a set of question fields (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>int?</returns>
        int? UpdateQuestionsInBulk (QuestionResource question = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);

        /// <summary>
        /// Bulk update questions
        /// </summary>
        /// <remarks>
        /// Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">New values for a set of question fields (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>ApiResponse of int?</returns>
        ApiResponse<int?> UpdateQuestionsInBulkWithHttpInfo (QuestionResource question = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);
        #endregion Synchronous Operations
        #region Asynchronous Operations
        /// <summary>
        /// Add an answer to a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="answer">The new answer (optional)</param>
        /// <returns>Task of AnswerResource</returns>
        System.Threading.Tasks.Task<AnswerResource> AddQuestionAnswersAsync (string questionId, AnswerResource answer = null);

        /// <summary>
        /// Add an answer to a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="answer">The new answer (optional)</param>
        /// <returns>Task of ApiResponse (AnswerResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<AnswerResource>> AddQuestionAnswersAsyncWithHttpInfo (string questionId, AnswerResource answer = null);
        /// <summary>
        /// Add a tag to a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The new tag (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task AddQuestionTagAsync (string id, string tag = null);

        /// <summary>
        /// Add a tag to a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The new tag (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AddQuestionTagAsyncWithHttpInfo (string id, string tag = null);
        /// <summary>
        /// Add a tag to a batch of questions
        /// </summary>
        /// <remarks>
        /// All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to add (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of int?</returns>
        System.Threading.Tasks.Task<int?> AddTagToQuestionsBatchAsync (string tag = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);

        /// <summary>
        /// Add a tag to a batch of questions
        /// </summary>
        /// <remarks>
        /// All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to add (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of ApiResponse (int?)</returns>
        System.Threading.Tasks.Task<ApiResponse<int?>> AddTagToQuestionsBatchAsyncWithHttpInfo (string tag = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);
        /// <summary>
        /// Create an import job
        /// </summary>
        /// <remarks>
        /// Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The new import job (optional)</param>
        /// <returns>Task of ImportJobResource</returns>
        System.Threading.Tasks.Task<ImportJobResource> CreateImportJobAsync (ImportJobResource request = null);

        /// <summary>
        /// Create an import job
        /// </summary>
        /// <remarks>
        /// Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The new import job (optional)</param>
        /// <returns>Task of ApiResponse (ImportJobResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<ImportJobResource>> CreateImportJobAsyncWithHttpInfo (ImportJobResource request = null);
        /// <summary>
        /// Create a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">The new question (optional)</param>
        /// <returns>Task of QuestionResource</returns>
        System.Threading.Tasks.Task<QuestionResource> CreateQuestionAsync (QuestionResource question = null);

        /// <summary>
        /// Create a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">The new question (optional)</param>
        /// <returns>Task of ApiResponse (QuestionResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<QuestionResource>> CreateQuestionAsyncWithHttpInfo (QuestionResource question = null);
        /// <summary>
        /// Create a question template
        /// </summary>
        /// <remarks>
        /// Question templates define a type of question and the properties they have
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>Task of QuestionTemplateResource</returns>
        System.Threading.Tasks.Task<QuestionTemplateResource> CreateQuestionTemplateAsync (QuestionTemplateResource questionTemplateResource = null);

        /// <summary>
        /// Create a question template
        /// </summary>
        /// <remarks>
        /// Question templates define a type of question and the properties they have
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>Task of ApiResponse (QuestionTemplateResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<QuestionTemplateResource>> CreateQuestionTemplateAsyncWithHttpInfo (QuestionTemplateResource questionTemplateResource = null);
        /// <summary>
        /// Delete an import job
        /// </summary>
        /// <remarks>
        /// Also deletes all questions that were imported by it
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteImportJobAsync (long? id);

        /// <summary>
        /// Delete an import job
        /// </summary>
        /// <remarks>
        /// Also deletes all questions that were imported by it
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteImportJobAsyncWithHttpInfo (long? id);
        /// <summary>
        /// Delete a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteQuestionAsync (string id);

        /// <summary>
        /// Delete a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteQuestionAsyncWithHttpInfo (string id);
        /// <summary>
        /// Remove an answer from a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteQuestionAnswersAsync (string questionId, string id);

        /// <summary>
        /// Remove an answer from a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteQuestionAnswersAsyncWithHttpInfo (string questionId, string id);
        /// <summary>
        /// Delete a question template
        /// </summary>
        /// <remarks>
        /// If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="cascade">The value needed to delete used templates (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteQuestionTemplateAsync (string id, string cascade = null);

        /// <summary>
        /// Delete a question template
        /// </summary>
        /// <remarks>
        /// If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="cascade">The value needed to delete used templates (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteQuestionTemplateAsyncWithHttpInfo (string id, string cascade = null);
        /// <summary>
        /// Get an import job
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>Task of ImportJobResource</returns>
        System.Threading.Tasks.Task<ImportJobResource> GetImportJobAsync (long? id);

        /// <summary>
        /// Get an import job
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>Task of ApiResponse (ImportJobResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<ImportJobResource>> GetImportJobAsyncWithHttpInfo (long? id);
        /// <summary>
        /// Get a list of import job
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterVendor">Filter for jobs by vendor id (optional)</param>
        /// <param name="filterCategory">Filter for jobs by category id (optional)</param>
        /// <param name="filterName">Filter for jobs which name *STARTS* with the given string (optional)</param>
        /// <param name="filterStatus">Filter for jobs that are in a specific set of statuses (comma separated) (optional)</param>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>Task of PageResourceImportJobResource</returns>
        System.Threading.Tasks.Task<PageResourceImportJobResource> GetImportJobsAsync (string filterVendor = null, string filterCategory = null, string filterName = null, string filterStatus = null, int? size = null, int? page = null, string order = null);

        /// <summary>
        /// Get a list of import job
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterVendor">Filter for jobs by vendor id (optional)</param>
        /// <param name="filterCategory">Filter for jobs by category id (optional)</param>
        /// <param name="filterName">Filter for jobs which name *STARTS* with the given string (optional)</param>
        /// <param name="filterStatus">Filter for jobs that are in a specific set of statuses (comma separated) (optional)</param>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>Task of ApiResponse (PageResourceImportJobResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageResourceImportJobResource>> GetImportJobsAsyncWithHttpInfo (string filterVendor = null, string filterCategory = null, string filterName = null, string filterStatus = null, int? size = null, int? page = null, string order = null);
        /// <summary>
        /// Get a single question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>Task of QuestionResource</returns>
        System.Threading.Tasks.Task<QuestionResource> GetQuestionAsync (string id);

        /// <summary>
        /// Get a single question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>Task of ApiResponse (QuestionResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<QuestionResource>> GetQuestionAsyncWithHttpInfo (string id);
        /// <summary>
        /// Get an answer for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>Task of AnswerResource</returns>
        System.Threading.Tasks.Task<AnswerResource> GetQuestionAnswerAsync (string questionId, string id);

        /// <summary>
        /// Get an answer for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>Task of ApiResponse (AnswerResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<AnswerResource>> GetQuestionAnswerAsyncWithHttpInfo (string questionId, string id);
        /// <summary>
        /// List the answers available for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <returns>Task of List&lt;AnswerResource&gt;</returns>
        System.Threading.Tasks.Task<List<AnswerResource>> GetQuestionAnswersAsync (string questionId);

        /// <summary>
        /// List the answers available for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <returns>Task of ApiResponse (List&lt;AnswerResource&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<AnswerResource>>> GetQuestionAnswersAsyncWithHttpInfo (string questionId);
        /// <summary>
        /// List question deltas in ascending order of updated date
        /// </summary>
        /// <remarks>
        /// The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="since">Timestamp in seconds (optional)</param>
        /// <returns>Task of List&lt;DeltaResource&gt;</returns>
        System.Threading.Tasks.Task<List<DeltaResource>> GetQuestionDeltasAsync (long? since = null);

        /// <summary>
        /// List question deltas in ascending order of updated date
        /// </summary>
        /// <remarks>
        /// The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="since">Timestamp in seconds (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;DeltaResource&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<DeltaResource>>> GetQuestionDeltasAsyncWithHttpInfo (long? since = null);
        /// <summary>
        /// List the tags for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>Task of List&lt;string&gt;</returns>
        System.Threading.Tasks.Task<List<string>> GetQuestionTagsAsync (string id);

        /// <summary>
        /// List the tags for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>Task of ApiResponse (List&lt;string&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<string>>> GetQuestionTagsAsyncWithHttpInfo (string id);
        /// <summary>
        /// Get a single question template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <returns>Task of QuestionTemplateResource</returns>
        System.Threading.Tasks.Task<QuestionTemplateResource> GetQuestionTemplateAsync (string id);

        /// <summary>
        /// Get a single question template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <returns>Task of ApiResponse (QuestionTemplateResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<QuestionTemplateResource>> GetQuestionTemplateAsyncWithHttpInfo (string id);
        /// <summary>
        /// List and search question templates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>Task of PageResourceQuestionTemplateResource</returns>
        System.Threading.Tasks.Task<PageResourceQuestionTemplateResource> GetQuestionTemplatesAsync (int? size = null, int? page = null, string order = null);

        /// <summary>
        /// List and search question templates
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>Task of ApiResponse (PageResourceQuestionTemplateResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageResourceQuestionTemplateResource>> GetQuestionTemplatesAsyncWithHttpInfo (int? size = null, int? page = null, string order = null);
        /// <summary>
        /// List and search questions
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of PageResourceQuestionResource</returns>
        System.Threading.Tasks.Task<PageResourceQuestionResource> GetQuestionsAsync (int? size = null, int? page = null, string order = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterTag = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);

        /// <summary>
        /// List and search questions
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of ApiResponse (PageResourceQuestionResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageResourceQuestionResource>> GetQuestionsAsyncWithHttpInfo (int? size = null, int? page = null, string order = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterTag = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);
        /// <summary>
        /// Count questions based on filters
        /// </summary>
        /// <remarks>
        /// This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <returns>Task of long?</returns>
        System.Threading.Tasks.Task<long?> GetQuestionsCountAsync (string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null);

        /// <summary>
        /// Count questions based on filters
        /// </summary>
        /// <remarks>
        /// This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <returns>Task of ApiResponse (long?)</returns>
        System.Threading.Tasks.Task<ApiResponse<long?>> GetQuestionsCountAsyncWithHttpInfo (string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null);
        /// <summary>
        /// Start processing an import job
        /// </summary>
        /// <remarks>
        /// Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="publishNow">Whether the new questions should be published live immediately</param>
        /// <returns>Task of ImportJobResource</returns>
        System.Threading.Tasks.Task<ImportJobResource> ProcessImportJobAsync (long? id, bool? publishNow);

        /// <summary>
        /// Start processing an import job
        /// </summary>
        /// <remarks>
        /// Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="publishNow">Whether the new questions should be published live immediately</param>
        /// <returns>Task of ApiResponse (ImportJobResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<ImportJobResource>> ProcessImportJobAsyncWithHttpInfo (long? id, bool? publishNow);
        /// <summary>
        /// Remove a tag from a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The tag to remove</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task RemoveQuestionTagAsync (string id, string tag);

        /// <summary>
        /// Remove a tag from a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The tag to remove</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> RemoveQuestionTagAsyncWithHttpInfo (string id, string tag);
        /// <summary>
        /// Remove a tag from a batch of questions
        /// </summary>
        /// <remarks>
        /// ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to remove</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of int?</returns>
        System.Threading.Tasks.Task<int?> RemoveTagToQuestionsBatchAsync (string tag, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);

        /// <summary>
        /// Remove a tag from a batch of questions
        /// </summary>
        /// <remarks>
        /// ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to remove</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of ApiResponse (int?)</returns>
        System.Threading.Tasks.Task<ApiResponse<int?>> RemoveTagToQuestionsBatchAsyncWithHttpInfo (string tag, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);
        /// <summary>
        /// List and search tags by the beginning of the string
        /// </summary>
        /// <remarks>
        /// For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for tags starting with the given text (optional)</param>
        /// <param name="filterCategory">Filter for tags on questions from a specific category (optional)</param>
        /// <param name="filterImportId">Filter for tags on questions from a specific import job (optional)</param>
        /// <returns>Task of Collectionstring</returns>
        System.Threading.Tasks.Task<Collectionstring> SearchQuestionTagsAsync (string filterSearch = null, string filterCategory = null, long? filterImportId = null);

        /// <summary>
        /// List and search tags by the beginning of the string
        /// </summary>
        /// <remarks>
        /// For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for tags starting with the given text (optional)</param>
        /// <param name="filterCategory">Filter for tags on questions from a specific category (optional)</param>
        /// <param name="filterImportId">Filter for tags on questions from a specific import job (optional)</param>
        /// <returns>Task of ApiResponse (Collectionstring)</returns>
        System.Threading.Tasks.Task<ApiResponse<Collectionstring>> SearchQuestionTagsAsyncWithHttpInfo (string filterSearch = null, string filterCategory = null, long? filterImportId = null);
        /// <summary>
        /// Update an import job
        /// </summary>
        /// <remarks>
        /// Changes should be made before process is started for there to be any effect.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="request">The updated job (optional)</param>
        /// <returns>Task of ImportJobResource</returns>
        System.Threading.Tasks.Task<ImportJobResource> UpdateImportJobAsync (long? id, ImportJobResource request = null);

        /// <summary>
        /// Update an import job
        /// </summary>
        /// <remarks>
        /// Changes should be made before process is started for there to be any effect.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="request">The updated job (optional)</param>
        /// <returns>Task of ApiResponse (ImportJobResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<ImportJobResource>> UpdateImportJobAsyncWithHttpInfo (long? id, ImportJobResource request = null);
        /// <summary>
        /// Update a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="question">The updated question (optional)</param>
        /// <returns>Task of QuestionResource</returns>
        System.Threading.Tasks.Task<QuestionResource> UpdateQuestionAsync (string id, QuestionResource question = null);

        /// <summary>
        /// Update a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="question">The updated question (optional)</param>
        /// <returns>Task of ApiResponse (QuestionResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<QuestionResource>> UpdateQuestionAsyncWithHttpInfo (string id, QuestionResource question = null);
        /// <summary>
        /// Update an answer for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <param name="answer">The updated answer (optional)</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task UpdateQuestionAnswerAsync (string questionId, string id, AnswerResource answer = null);

        /// <summary>
        /// Update an answer for a question
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <param name="answer">The updated answer (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> UpdateQuestionAnswerAsyncWithHttpInfo (string questionId, string id, AnswerResource answer = null);
        /// <summary>
        /// Update a question template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>Task of QuestionTemplateResource</returns>
        System.Threading.Tasks.Task<QuestionTemplateResource> UpdateQuestionTemplateAsync (string id, QuestionTemplateResource questionTemplateResource = null);

        /// <summary>
        /// Update a question template
        /// </summary>
        /// <remarks>
        /// 
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>Task of ApiResponse (QuestionTemplateResource)</returns>
        System.Threading.Tasks.Task<ApiResponse<QuestionTemplateResource>> UpdateQuestionTemplateAsyncWithHttpInfo (string id, QuestionTemplateResource questionTemplateResource = null);
        /// <summary>
        /// Bulk update questions
        /// </summary>
        /// <remarks>
        /// Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">New values for a set of question fields (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of int?</returns>
        System.Threading.Tasks.Task<int?> UpdateQuestionsInBulkAsync (QuestionResource question = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);

        /// <summary>
        /// Bulk update questions
        /// </summary>
        /// <remarks>
        /// Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
        /// </remarks>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">New values for a set of question fields (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of ApiResponse (int?)</returns>
        System.Threading.Tasks.Task<ApiResponse<int?>> UpdateQuestionsInBulkAsyncWithHttpInfo (QuestionResource question = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null);
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class GamificationTriviaApi : IGamificationTriviaApi
    {
        private com.knetikcloud.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="GamificationTriviaApi"/> class.
        /// </summary>
        /// <returns></returns>
        public GamificationTriviaApi(String basePath)
        {
            this.Configuration = new Configuration(new ApiClient(basePath));

            ExceptionFactory = com.knetikcloud.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="GamificationTriviaApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public GamificationTriviaApi(Configuration configuration = null)
        {
            if (configuration == null) // use the default one in Configuration
                this.Configuration = Configuration.Default;
            else
                this.Configuration = configuration;

            ExceptionFactory = com.knetikcloud.Client.Configuration.DefaultExceptionFactory;

            // ensure API client has configuration ready
            if (Configuration.ApiClient.Configuration == null)
            {
                this.Configuration.ApiClient.Configuration = this.Configuration;
            }
        }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public String GetBasePath()
        {
            return this.Configuration.ApiClient.RestClient.BaseUrl.ToString();
        }

        /// <summary>
        /// Sets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        [Obsolete("SetBasePath is deprecated, please do 'Configuration.ApiClient = new ApiClient(\"http://new-path\")' instead.")]
        public void SetBasePath(String basePath)
        {
            // do nothing
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Configuration Configuration {get; set;}

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public com.knetikcloud.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Gets the default header.
        /// </summary>
        /// <returns>Dictionary of HTTP header</returns>
        [Obsolete("DefaultHeader is deprecated, please use Configuration.DefaultHeader instead.")]
        public Dictionary<String, String> DefaultHeader()
        {
            return this.Configuration.DefaultHeader;
        }

        /// <summary>
        /// Add default header.
        /// </summary>
        /// <param name="key">Header field name.</param>
        /// <param name="value">Header field value.</param>
        /// <returns></returns>
        [Obsolete("AddDefaultHeader is deprecated, please use Configuration.AddDefaultHeader instead.")]
        public void AddDefaultHeader(string key, string value)
        {
            this.Configuration.AddDefaultHeader(key, value);
        }

        /// <summary>
        /// Add an answer to a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="answer">The new answer (optional)</param>
        /// <returns>AnswerResource</returns>
        public AnswerResource AddQuestionAnswers (string questionId, AnswerResource answer = null)
        {
             ApiResponse<AnswerResource> localVarResponse = AddQuestionAnswersWithHttpInfo(questionId, answer);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Add an answer to a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="answer">The new answer (optional)</param>
        /// <returns>ApiResponse of AnswerResource</returns>
        public ApiResponse< AnswerResource > AddQuestionAnswersWithHttpInfo (string questionId, AnswerResource answer = null)
        {
            // verify the required parameter 'questionId' is set
            if (questionId == null)
                throw new ApiException(400, "Missing required parameter 'questionId' when calling GamificationTriviaApi->AddQuestionAnswers");

            var localVarPath = "/trivia/questions/{question_id}/answers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (questionId != null) localVarPathParams.Add("question_id", Configuration.ApiClient.ParameterToString(questionId)); // path parameter
            if (answer != null && answer.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(answer); // http body (model) parameter
            }
            else
            {
                localVarPostBody = answer; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddQuestionAnswers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AnswerResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AnswerResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(AnswerResource)));
            
        }

        /// <summary>
        /// Add an answer to a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="answer">The new answer (optional)</param>
        /// <returns>Task of AnswerResource</returns>
        public async System.Threading.Tasks.Task<AnswerResource> AddQuestionAnswersAsync (string questionId, AnswerResource answer = null)
        {
             ApiResponse<AnswerResource> localVarResponse = await AddQuestionAnswersAsyncWithHttpInfo(questionId, answer);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Add an answer to a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="answer">The new answer (optional)</param>
        /// <returns>Task of ApiResponse (AnswerResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AnswerResource>> AddQuestionAnswersAsyncWithHttpInfo (string questionId, AnswerResource answer = null)
        {
            // verify the required parameter 'questionId' is set
            if (questionId == null)
                throw new ApiException(400, "Missing required parameter 'questionId' when calling GamificationTriviaApi->AddQuestionAnswers");

            var localVarPath = "/trivia/questions/{question_id}/answers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (questionId != null) localVarPathParams.Add("question_id", Configuration.ApiClient.ParameterToString(questionId)); // path parameter
            if (answer != null && answer.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(answer); // http body (model) parameter
            }
            else
            {
                localVarPostBody = answer; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddQuestionAnswers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AnswerResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AnswerResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(AnswerResource)));
            
        }

        /// <summary>
        /// Add a tag to a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The new tag (optional)</param>
        /// <returns></returns>
        public void AddQuestionTag (string id, string tag = null)
        {
             AddQuestionTagWithHttpInfo(id, tag);
        }

        /// <summary>
        /// Add a tag to a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The new tag (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> AddQuestionTagWithHttpInfo (string id, string tag = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->AddQuestionTag");

            var localVarPath = "/trivia/questions/{id}/tags";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (tag != null && tag.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(tag); // http body (model) parameter
            }
            else
            {
                localVarPostBody = tag; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddQuestionTag", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Add a tag to a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The new tag (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task AddQuestionTagAsync (string id, string tag = null)
        {
             await AddQuestionTagAsyncWithHttpInfo(id, tag);

        }

        /// <summary>
        /// Add a tag to a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The new tag (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> AddQuestionTagAsyncWithHttpInfo (string id, string tag = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->AddQuestionTag");

            var localVarPath = "/trivia/questions/{id}/tags";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (tag != null && tag.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(tag); // http body (model) parameter
            }
            else
            {
                localVarPostBody = tag; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddQuestionTag", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Add a tag to a batch of questions All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to add (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>int?</returns>
        public int? AddTagToQuestionsBatch (string tag = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {
             ApiResponse<int?> localVarResponse = AddTagToQuestionsBatchWithHttpInfo(tag, filterSearch, filterIdset, filterCategory, filterTag, filterTagset, filterType, filterPublished, filterImportId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Add a tag to a batch of questions All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to add (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>ApiResponse of int?</returns>
        public ApiResponse< int? > AddTagToQuestionsBatchWithHttpInfo (string tag = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {

            var localVarPath = "/trivia/questions/tags";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (filterSearch != null) localVarQueryParams.Add("filter_search", Configuration.ApiClient.ParameterToString(filterSearch)); // query parameter
            if (filterIdset != null) localVarQueryParams.Add("filter_idset", Configuration.ApiClient.ParameterToString(filterIdset)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterTag != null) localVarQueryParams.Add("filter_tag", Configuration.ApiClient.ParameterToString(filterTag)); // query parameter
            if (filterTagset != null) localVarQueryParams.Add("filter_tagset", Configuration.ApiClient.ParameterToString(filterTagset)); // query parameter
            if (filterType != null) localVarQueryParams.Add("filter_type", Configuration.ApiClient.ParameterToString(filterType)); // query parameter
            if (filterPublished != null) localVarQueryParams.Add("filter_published", Configuration.ApiClient.ParameterToString(filterPublished)); // query parameter
            if (filterImportId != null) localVarQueryParams.Add("filter_import_id", Configuration.ApiClient.ParameterToString(filterImportId)); // query parameter
            if (tag != null && tag.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(tag); // http body (model) parameter
            }
            else
            {
                localVarPostBody = tag; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddTagToQuestionsBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<int?>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (int?) Configuration.ApiClient.Deserialize(localVarResponse, typeof(int?)));
            
        }

        /// <summary>
        /// Add a tag to a batch of questions All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to add (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of int?</returns>
        public async System.Threading.Tasks.Task<int?> AddTagToQuestionsBatchAsync (string tag = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {
             ApiResponse<int?> localVarResponse = await AddTagToQuestionsBatchAsyncWithHttpInfo(tag, filterSearch, filterIdset, filterCategory, filterTag, filterTagset, filterType, filterPublished, filterImportId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Add a tag to a batch of questions All questions that dont&#39;t have the tag and match filters will have it added. The returned number is the number of questions updated.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to add (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of ApiResponse (int?)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<int?>> AddTagToQuestionsBatchAsyncWithHttpInfo (string tag = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {

            var localVarPath = "/trivia/questions/tags";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (filterSearch != null) localVarQueryParams.Add("filter_search", Configuration.ApiClient.ParameterToString(filterSearch)); // query parameter
            if (filterIdset != null) localVarQueryParams.Add("filter_idset", Configuration.ApiClient.ParameterToString(filterIdset)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterTag != null) localVarQueryParams.Add("filter_tag", Configuration.ApiClient.ParameterToString(filterTag)); // query parameter
            if (filterTagset != null) localVarQueryParams.Add("filter_tagset", Configuration.ApiClient.ParameterToString(filterTagset)); // query parameter
            if (filterType != null) localVarQueryParams.Add("filter_type", Configuration.ApiClient.ParameterToString(filterType)); // query parameter
            if (filterPublished != null) localVarQueryParams.Add("filter_published", Configuration.ApiClient.ParameterToString(filterPublished)); // query parameter
            if (filterImportId != null) localVarQueryParams.Add("filter_import_id", Configuration.ApiClient.ParameterToString(filterImportId)); // query parameter
            if (tag != null && tag.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(tag); // http body (model) parameter
            }
            else
            {
                localVarPostBody = tag; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("AddTagToQuestionsBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<int?>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (int?) Configuration.ApiClient.Deserialize(localVarResponse, typeof(int?)));
            
        }

        /// <summary>
        /// Create an import job Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The new import job (optional)</param>
        /// <returns>ImportJobResource</returns>
        public ImportJobResource CreateImportJob (ImportJobResource request = null)
        {
             ApiResponse<ImportJobResource> localVarResponse = CreateImportJobWithHttpInfo(request);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create an import job Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The new import job (optional)</param>
        /// <returns>ApiResponse of ImportJobResource</returns>
        public ApiResponse< ImportJobResource > CreateImportJobWithHttpInfo (ImportJobResource request = null)
        {

            var localVarPath = "/trivia/import";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateImportJob", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ImportJobResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ImportJobResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ImportJobResource)));
            
        }

        /// <summary>
        /// Create an import job Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The new import job (optional)</param>
        /// <returns>Task of ImportJobResource</returns>
        public async System.Threading.Tasks.Task<ImportJobResource> CreateImportJobAsync (ImportJobResource request = null)
        {
             ApiResponse<ImportJobResource> localVarResponse = await CreateImportJobAsyncWithHttpInfo(request);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create an import job Set up a job to import a set of trivia questions from a cvs file at a remote url. the file will be validated asynchronously but will not be processed until started manually with the process endpoint.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="request">The new import job (optional)</param>
        /// <returns>Task of ApiResponse (ImportJobResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ImportJobResource>> CreateImportJobAsyncWithHttpInfo (ImportJobResource request = null)
        {

            var localVarPath = "/trivia/import";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateImportJob", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ImportJobResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ImportJobResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ImportJobResource)));
            
        }

        /// <summary>
        /// Create a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">The new question (optional)</param>
        /// <returns>QuestionResource</returns>
        public QuestionResource CreateQuestion (QuestionResource question = null)
        {
             ApiResponse<QuestionResource> localVarResponse = CreateQuestionWithHttpInfo(question);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">The new question (optional)</param>
        /// <returns>ApiResponse of QuestionResource</returns>
        public ApiResponse< QuestionResource > CreateQuestionWithHttpInfo (QuestionResource question = null)
        {

            var localVarPath = "/trivia/questions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (question != null && question.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(question); // http body (model) parameter
            }
            else
            {
                localVarPostBody = question; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateQuestion", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuestionResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (QuestionResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuestionResource)));
            
        }

        /// <summary>
        /// Create a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">The new question (optional)</param>
        /// <returns>Task of QuestionResource</returns>
        public async System.Threading.Tasks.Task<QuestionResource> CreateQuestionAsync (QuestionResource question = null)
        {
             ApiResponse<QuestionResource> localVarResponse = await CreateQuestionAsyncWithHttpInfo(question);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">The new question (optional)</param>
        /// <returns>Task of ApiResponse (QuestionResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QuestionResource>> CreateQuestionAsyncWithHttpInfo (QuestionResource question = null)
        {

            var localVarPath = "/trivia/questions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (question != null && question.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(question); // http body (model) parameter
            }
            else
            {
                localVarPostBody = question; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateQuestion", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuestionResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (QuestionResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuestionResource)));
            
        }

        /// <summary>
        /// Create a question template Question templates define a type of question and the properties they have
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>QuestionTemplateResource</returns>
        public QuestionTemplateResource CreateQuestionTemplate (QuestionTemplateResource questionTemplateResource = null)
        {
             ApiResponse<QuestionTemplateResource> localVarResponse = CreateQuestionTemplateWithHttpInfo(questionTemplateResource);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Create a question template Question templates define a type of question and the properties they have
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>ApiResponse of QuestionTemplateResource</returns>
        public ApiResponse< QuestionTemplateResource > CreateQuestionTemplateWithHttpInfo (QuestionTemplateResource questionTemplateResource = null)
        {

            var localVarPath = "/trivia/questions/templates";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (questionTemplateResource != null && questionTemplateResource.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(questionTemplateResource); // http body (model) parameter
            }
            else
            {
                localVarPostBody = questionTemplateResource; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateQuestionTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuestionTemplateResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (QuestionTemplateResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuestionTemplateResource)));
            
        }

        /// <summary>
        /// Create a question template Question templates define a type of question and the properties they have
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>Task of QuestionTemplateResource</returns>
        public async System.Threading.Tasks.Task<QuestionTemplateResource> CreateQuestionTemplateAsync (QuestionTemplateResource questionTemplateResource = null)
        {
             ApiResponse<QuestionTemplateResource> localVarResponse = await CreateQuestionTemplateAsyncWithHttpInfo(questionTemplateResource);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Create a question template Question templates define a type of question and the properties they have
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>Task of ApiResponse (QuestionTemplateResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QuestionTemplateResource>> CreateQuestionTemplateAsyncWithHttpInfo (QuestionTemplateResource questionTemplateResource = null)
        {

            var localVarPath = "/trivia/questions/templates";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (questionTemplateResource != null && questionTemplateResource.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(questionTemplateResource); // http body (model) parameter
            }
            else
            {
                localVarPostBody = questionTemplateResource; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("CreateQuestionTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuestionTemplateResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (QuestionTemplateResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuestionTemplateResource)));
            
        }

        /// <summary>
        /// Delete an import job Also deletes all questions that were imported by it
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns></returns>
        public void DeleteImportJob (long? id)
        {
             DeleteImportJobWithHttpInfo(id);
        }

        /// <summary>
        /// Delete an import job Also deletes all questions that were imported by it
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteImportJobWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->DeleteImportJob");

            var localVarPath = "/trivia/import/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteImportJob", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete an import job Also deletes all questions that were imported by it
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteImportJobAsync (long? id)
        {
             await DeleteImportJobAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Delete an import job Also deletes all questions that were imported by it
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteImportJobAsyncWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->DeleteImportJob");

            var localVarPath = "/trivia/import/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteImportJob", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns></returns>
        public void DeleteQuestion (string id)
        {
             DeleteQuestionWithHttpInfo(id);
        }

        /// <summary>
        /// Delete a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteQuestionWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->DeleteQuestion");

            var localVarPath = "/trivia/questions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteQuestion", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteQuestionAsync (string id)
        {
             await DeleteQuestionAsyncWithHttpInfo(id);

        }

        /// <summary>
        /// Delete a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteQuestionAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->DeleteQuestion");

            var localVarPath = "/trivia/questions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteQuestion", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Remove an answer from a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns></returns>
        public void DeleteQuestionAnswers (string questionId, string id)
        {
             DeleteQuestionAnswersWithHttpInfo(questionId, id);
        }

        /// <summary>
        /// Remove an answer from a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteQuestionAnswersWithHttpInfo (string questionId, string id)
        {
            // verify the required parameter 'questionId' is set
            if (questionId == null)
                throw new ApiException(400, "Missing required parameter 'questionId' when calling GamificationTriviaApi->DeleteQuestionAnswers");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->DeleteQuestionAnswers");

            var localVarPath = "/trivia/questions/{question_id}/answers/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (questionId != null) localVarPathParams.Add("question_id", Configuration.ApiClient.ParameterToString(questionId)); // path parameter
            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteQuestionAnswers", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Remove an answer from a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteQuestionAnswersAsync (string questionId, string id)
        {
             await DeleteQuestionAnswersAsyncWithHttpInfo(questionId, id);

        }

        /// <summary>
        /// Remove an answer from a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteQuestionAnswersAsyncWithHttpInfo (string questionId, string id)
        {
            // verify the required parameter 'questionId' is set
            if (questionId == null)
                throw new ApiException(400, "Missing required parameter 'questionId' when calling GamificationTriviaApi->DeleteQuestionAnswers");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->DeleteQuestionAnswers");

            var localVarPath = "/trivia/questions/{question_id}/answers/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (questionId != null) localVarPathParams.Add("question_id", Configuration.ApiClient.ParameterToString(questionId)); // path parameter
            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteQuestionAnswers", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a question template If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="cascade">The value needed to delete used templates (optional)</param>
        /// <returns></returns>
        public void DeleteQuestionTemplate (string id, string cascade = null)
        {
             DeleteQuestionTemplateWithHttpInfo(id, cascade);
        }

        /// <summary>
        /// Delete a question template If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="cascade">The value needed to delete used templates (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> DeleteQuestionTemplateWithHttpInfo (string id, string cascade = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->DeleteQuestionTemplate");

            var localVarPath = "/trivia/questions/templates/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (cascade != null) localVarQueryParams.Add("cascade", Configuration.ApiClient.ParameterToString(cascade)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteQuestionTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Delete a question template If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="cascade">The value needed to delete used templates (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteQuestionTemplateAsync (string id, string cascade = null)
        {
             await DeleteQuestionTemplateAsyncWithHttpInfo(id, cascade);

        }

        /// <summary>
        /// Delete a question template If cascade &#x3D; &#39;detach&#39;, it will force delete the template even if it&#39;s attached to other objects
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="cascade">The value needed to delete used templates (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> DeleteQuestionTemplateAsyncWithHttpInfo (string id, string cascade = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->DeleteQuestionTemplate");

            var localVarPath = "/trivia/questions/templates/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (cascade != null) localVarQueryParams.Add("cascade", Configuration.ApiClient.ParameterToString(cascade)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("DeleteQuestionTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Get an import job 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>ImportJobResource</returns>
        public ImportJobResource GetImportJob (long? id)
        {
             ApiResponse<ImportJobResource> localVarResponse = GetImportJobWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get an import job 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>ApiResponse of ImportJobResource</returns>
        public ApiResponse< ImportJobResource > GetImportJobWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->GetImportJob");

            var localVarPath = "/trivia/import/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetImportJob", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ImportJobResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ImportJobResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ImportJobResource)));
            
        }

        /// <summary>
        /// Get an import job 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>Task of ImportJobResource</returns>
        public async System.Threading.Tasks.Task<ImportJobResource> GetImportJobAsync (long? id)
        {
             ApiResponse<ImportJobResource> localVarResponse = await GetImportJobAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get an import job 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <returns>Task of ApiResponse (ImportJobResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ImportJobResource>> GetImportJobAsyncWithHttpInfo (long? id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->GetImportJob");

            var localVarPath = "/trivia/import/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetImportJob", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ImportJobResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ImportJobResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ImportJobResource)));
            
        }

        /// <summary>
        /// Get a list of import job 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterVendor">Filter for jobs by vendor id (optional)</param>
        /// <param name="filterCategory">Filter for jobs by category id (optional)</param>
        /// <param name="filterName">Filter for jobs which name *STARTS* with the given string (optional)</param>
        /// <param name="filterStatus">Filter for jobs that are in a specific set of statuses (comma separated) (optional)</param>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>PageResourceImportJobResource</returns>
        public PageResourceImportJobResource GetImportJobs (string filterVendor = null, string filterCategory = null, string filterName = null, string filterStatus = null, int? size = null, int? page = null, string order = null)
        {
             ApiResponse<PageResourceImportJobResource> localVarResponse = GetImportJobsWithHttpInfo(filterVendor, filterCategory, filterName, filterStatus, size, page, order);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a list of import job 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterVendor">Filter for jobs by vendor id (optional)</param>
        /// <param name="filterCategory">Filter for jobs by category id (optional)</param>
        /// <param name="filterName">Filter for jobs which name *STARTS* with the given string (optional)</param>
        /// <param name="filterStatus">Filter for jobs that are in a specific set of statuses (comma separated) (optional)</param>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>ApiResponse of PageResourceImportJobResource</returns>
        public ApiResponse< PageResourceImportJobResource > GetImportJobsWithHttpInfo (string filterVendor = null, string filterCategory = null, string filterName = null, string filterStatus = null, int? size = null, int? page = null, string order = null)
        {

            var localVarPath = "/trivia/import";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (filterVendor != null) localVarQueryParams.Add("filter_vendor", Configuration.ApiClient.ParameterToString(filterVendor)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterName != null) localVarQueryParams.Add("filter_name", Configuration.ApiClient.ParameterToString(filterName)); // query parameter
            if (filterStatus != null) localVarQueryParams.Add("filter_status", Configuration.ApiClient.ParameterToString(filterStatus)); // query parameter
            if (size != null) localVarQueryParams.Add("size", Configuration.ApiClient.ParameterToString(size)); // query parameter
            if (page != null) localVarQueryParams.Add("page", Configuration.ApiClient.ParameterToString(page)); // query parameter
            if (order != null) localVarQueryParams.Add("order", Configuration.ApiClient.ParameterToString(order)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetImportJobs", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PageResourceImportJobResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (PageResourceImportJobResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(PageResourceImportJobResource)));
            
        }

        /// <summary>
        /// Get a list of import job 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterVendor">Filter for jobs by vendor id (optional)</param>
        /// <param name="filterCategory">Filter for jobs by category id (optional)</param>
        /// <param name="filterName">Filter for jobs which name *STARTS* with the given string (optional)</param>
        /// <param name="filterStatus">Filter for jobs that are in a specific set of statuses (comma separated) (optional)</param>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>Task of PageResourceImportJobResource</returns>
        public async System.Threading.Tasks.Task<PageResourceImportJobResource> GetImportJobsAsync (string filterVendor = null, string filterCategory = null, string filterName = null, string filterStatus = null, int? size = null, int? page = null, string order = null)
        {
             ApiResponse<PageResourceImportJobResource> localVarResponse = await GetImportJobsAsyncWithHttpInfo(filterVendor, filterCategory, filterName, filterStatus, size, page, order);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a list of import job 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterVendor">Filter for jobs by vendor id (optional)</param>
        /// <param name="filterCategory">Filter for jobs by category id (optional)</param>
        /// <param name="filterName">Filter for jobs which name *STARTS* with the given string (optional)</param>
        /// <param name="filterStatus">Filter for jobs that are in a specific set of statuses (comma separated) (optional)</param>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>Task of ApiResponse (PageResourceImportJobResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PageResourceImportJobResource>> GetImportJobsAsyncWithHttpInfo (string filterVendor = null, string filterCategory = null, string filterName = null, string filterStatus = null, int? size = null, int? page = null, string order = null)
        {

            var localVarPath = "/trivia/import";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (filterVendor != null) localVarQueryParams.Add("filter_vendor", Configuration.ApiClient.ParameterToString(filterVendor)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterName != null) localVarQueryParams.Add("filter_name", Configuration.ApiClient.ParameterToString(filterName)); // query parameter
            if (filterStatus != null) localVarQueryParams.Add("filter_status", Configuration.ApiClient.ParameterToString(filterStatus)); // query parameter
            if (size != null) localVarQueryParams.Add("size", Configuration.ApiClient.ParameterToString(size)); // query parameter
            if (page != null) localVarQueryParams.Add("page", Configuration.ApiClient.ParameterToString(page)); // query parameter
            if (order != null) localVarQueryParams.Add("order", Configuration.ApiClient.ParameterToString(order)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetImportJobs", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PageResourceImportJobResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (PageResourceImportJobResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(PageResourceImportJobResource)));
            
        }

        /// <summary>
        /// Get a single question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>QuestionResource</returns>
        public QuestionResource GetQuestion (string id)
        {
             ApiResponse<QuestionResource> localVarResponse = GetQuestionWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a single question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>ApiResponse of QuestionResource</returns>
        public ApiResponse< QuestionResource > GetQuestionWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->GetQuestion");

            var localVarPath = "/trivia/questions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestion", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuestionResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (QuestionResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuestionResource)));
            
        }

        /// <summary>
        /// Get a single question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>Task of QuestionResource</returns>
        public async System.Threading.Tasks.Task<QuestionResource> GetQuestionAsync (string id)
        {
             ApiResponse<QuestionResource> localVarResponse = await GetQuestionAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a single question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>Task of ApiResponse (QuestionResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QuestionResource>> GetQuestionAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->GetQuestion");

            var localVarPath = "/trivia/questions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestion", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuestionResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (QuestionResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuestionResource)));
            
        }

        /// <summary>
        /// Get an answer for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>AnswerResource</returns>
        public AnswerResource GetQuestionAnswer (string questionId, string id)
        {
             ApiResponse<AnswerResource> localVarResponse = GetQuestionAnswerWithHttpInfo(questionId, id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get an answer for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>ApiResponse of AnswerResource</returns>
        public ApiResponse< AnswerResource > GetQuestionAnswerWithHttpInfo (string questionId, string id)
        {
            // verify the required parameter 'questionId' is set
            if (questionId == null)
                throw new ApiException(400, "Missing required parameter 'questionId' when calling GamificationTriviaApi->GetQuestionAnswer");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->GetQuestionAnswer");

            var localVarPath = "/trivia/questions/{question_id}/answers/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (questionId != null) localVarPathParams.Add("question_id", Configuration.ApiClient.ParameterToString(questionId)); // path parameter
            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionAnswer", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AnswerResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AnswerResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(AnswerResource)));
            
        }

        /// <summary>
        /// Get an answer for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>Task of AnswerResource</returns>
        public async System.Threading.Tasks.Task<AnswerResource> GetQuestionAnswerAsync (string questionId, string id)
        {
             ApiResponse<AnswerResource> localVarResponse = await GetQuestionAnswerAsyncWithHttpInfo(questionId, id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get an answer for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <returns>Task of ApiResponse (AnswerResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<AnswerResource>> GetQuestionAnswerAsyncWithHttpInfo (string questionId, string id)
        {
            // verify the required parameter 'questionId' is set
            if (questionId == null)
                throw new ApiException(400, "Missing required parameter 'questionId' when calling GamificationTriviaApi->GetQuestionAnswer");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->GetQuestionAnswer");

            var localVarPath = "/trivia/questions/{question_id}/answers/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (questionId != null) localVarPathParams.Add("question_id", Configuration.ApiClient.ParameterToString(questionId)); // path parameter
            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionAnswer", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<AnswerResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (AnswerResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(AnswerResource)));
            
        }

        /// <summary>
        /// List the answers available for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <returns>List&lt;AnswerResource&gt;</returns>
        public List<AnswerResource> GetQuestionAnswers (string questionId)
        {
             ApiResponse<List<AnswerResource>> localVarResponse = GetQuestionAnswersWithHttpInfo(questionId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List the answers available for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <returns>ApiResponse of List&lt;AnswerResource&gt;</returns>
        public ApiResponse< List<AnswerResource> > GetQuestionAnswersWithHttpInfo (string questionId)
        {
            // verify the required parameter 'questionId' is set
            if (questionId == null)
                throw new ApiException(400, "Missing required parameter 'questionId' when calling GamificationTriviaApi->GetQuestionAnswers");

            var localVarPath = "/trivia/questions/{question_id}/answers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (questionId != null) localVarPathParams.Add("question_id", Configuration.ApiClient.ParameterToString(questionId)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionAnswers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<AnswerResource>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<AnswerResource>) Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<AnswerResource>)));
            
        }

        /// <summary>
        /// List the answers available for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <returns>Task of List&lt;AnswerResource&gt;</returns>
        public async System.Threading.Tasks.Task<List<AnswerResource>> GetQuestionAnswersAsync (string questionId)
        {
             ApiResponse<List<AnswerResource>> localVarResponse = await GetQuestionAnswersAsyncWithHttpInfo(questionId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List the answers available for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <returns>Task of ApiResponse (List&lt;AnswerResource&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<AnswerResource>>> GetQuestionAnswersAsyncWithHttpInfo (string questionId)
        {
            // verify the required parameter 'questionId' is set
            if (questionId == null)
                throw new ApiException(400, "Missing required parameter 'questionId' when calling GamificationTriviaApi->GetQuestionAnswers");

            var localVarPath = "/trivia/questions/{question_id}/answers";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (questionId != null) localVarPathParams.Add("question_id", Configuration.ApiClient.ParameterToString(questionId)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionAnswers", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<AnswerResource>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<AnswerResource>) Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<AnswerResource>)));
            
        }

        /// <summary>
        /// List question deltas in ascending order of updated date The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="since">Timestamp in seconds (optional)</param>
        /// <returns>List&lt;DeltaResource&gt;</returns>
        public List<DeltaResource> GetQuestionDeltas (long? since = null)
        {
             ApiResponse<List<DeltaResource>> localVarResponse = GetQuestionDeltasWithHttpInfo(since);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List question deltas in ascending order of updated date The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="since">Timestamp in seconds (optional)</param>
        /// <returns>ApiResponse of List&lt;DeltaResource&gt;</returns>
        public ApiResponse< List<DeltaResource> > GetQuestionDeltasWithHttpInfo (long? since = null)
        {

            var localVarPath = "/trivia/questions/delta";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (since != null) localVarQueryParams.Add("since", Configuration.ApiClient.ParameterToString(since)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionDeltas", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<DeltaResource>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<DeltaResource>) Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<DeltaResource>)));
            
        }

        /// <summary>
        /// List question deltas in ascending order of updated date The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="since">Timestamp in seconds (optional)</param>
        /// <returns>Task of List&lt;DeltaResource&gt;</returns>
        public async System.Threading.Tasks.Task<List<DeltaResource>> GetQuestionDeltasAsync (long? since = null)
        {
             ApiResponse<List<DeltaResource>> localVarResponse = await GetQuestionDeltasAsyncWithHttpInfo(since);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List question deltas in ascending order of updated date The &#39;since&#39; parameter is important to avoid getting a full list of all questions. Implementors should make sure they pass the updated date of the last resource loaded, not the date of the last request, in order to avoid gaps
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="since">Timestamp in seconds (optional)</param>
        /// <returns>Task of ApiResponse (List&lt;DeltaResource&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<DeltaResource>>> GetQuestionDeltasAsyncWithHttpInfo (long? since = null)
        {

            var localVarPath = "/trivia/questions/delta";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (since != null) localVarQueryParams.Add("since", Configuration.ApiClient.ParameterToString(since)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionDeltas", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<DeltaResource>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<DeltaResource>) Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<DeltaResource>)));
            
        }

        /// <summary>
        /// List the tags for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>List&lt;string&gt;</returns>
        public List<string> GetQuestionTags (string id)
        {
             ApiResponse<List<string>> localVarResponse = GetQuestionTagsWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List the tags for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>ApiResponse of List&lt;string&gt;</returns>
        public ApiResponse< List<string> > GetQuestionTagsWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->GetQuestionTags");

            var localVarPath = "/trivia/questions/{id}/tags";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionTags", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<string>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<string>) Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<string>)));
            
        }

        /// <summary>
        /// List the tags for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>Task of List&lt;string&gt;</returns>
        public async System.Threading.Tasks.Task<List<string>> GetQuestionTagsAsync (string id)
        {
             ApiResponse<List<string>> localVarResponse = await GetQuestionTagsAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List the tags for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <returns>Task of ApiResponse (List&lt;string&gt;)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<List<string>>> GetQuestionTagsAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->GetQuestionTags");

            var localVarPath = "/trivia/questions/{id}/tags";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionTags", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<List<string>>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (List<string>) Configuration.ApiClient.Deserialize(localVarResponse, typeof(List<string>)));
            
        }

        /// <summary>
        /// Get a single question template 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <returns>QuestionTemplateResource</returns>
        public QuestionTemplateResource GetQuestionTemplate (string id)
        {
             ApiResponse<QuestionTemplateResource> localVarResponse = GetQuestionTemplateWithHttpInfo(id);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Get a single question template 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <returns>ApiResponse of QuestionTemplateResource</returns>
        public ApiResponse< QuestionTemplateResource > GetQuestionTemplateWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->GetQuestionTemplate");

            var localVarPath = "/trivia/questions/templates/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuestionTemplateResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (QuestionTemplateResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuestionTemplateResource)));
            
        }

        /// <summary>
        /// Get a single question template 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <returns>Task of QuestionTemplateResource</returns>
        public async System.Threading.Tasks.Task<QuestionTemplateResource> GetQuestionTemplateAsync (string id)
        {
             ApiResponse<QuestionTemplateResource> localVarResponse = await GetQuestionTemplateAsyncWithHttpInfo(id);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Get a single question template 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <returns>Task of ApiResponse (QuestionTemplateResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QuestionTemplateResource>> GetQuestionTemplateAsyncWithHttpInfo (string id)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->GetQuestionTemplate");

            var localVarPath = "/trivia/questions/templates/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuestionTemplateResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (QuestionTemplateResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuestionTemplateResource)));
            
        }

        /// <summary>
        /// List and search question templates 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>PageResourceQuestionTemplateResource</returns>
        public PageResourceQuestionTemplateResource GetQuestionTemplates (int? size = null, int? page = null, string order = null)
        {
             ApiResponse<PageResourceQuestionTemplateResource> localVarResponse = GetQuestionTemplatesWithHttpInfo(size, page, order);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List and search question templates 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>ApiResponse of PageResourceQuestionTemplateResource</returns>
        public ApiResponse< PageResourceQuestionTemplateResource > GetQuestionTemplatesWithHttpInfo (int? size = null, int? page = null, string order = null)
        {

            var localVarPath = "/trivia/questions/templates";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (size != null) localVarQueryParams.Add("size", Configuration.ApiClient.ParameterToString(size)); // query parameter
            if (page != null) localVarQueryParams.Add("page", Configuration.ApiClient.ParameterToString(page)); // query parameter
            if (order != null) localVarQueryParams.Add("order", Configuration.ApiClient.ParameterToString(order)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionTemplates", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PageResourceQuestionTemplateResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (PageResourceQuestionTemplateResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(PageResourceQuestionTemplateResource)));
            
        }

        /// <summary>
        /// List and search question templates 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>Task of PageResourceQuestionTemplateResource</returns>
        public async System.Threading.Tasks.Task<PageResourceQuestionTemplateResource> GetQuestionTemplatesAsync (int? size = null, int? page = null, string order = null)
        {
             ApiResponse<PageResourceQuestionTemplateResource> localVarResponse = await GetQuestionTemplatesAsyncWithHttpInfo(size, page, order);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List and search question templates 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <returns>Task of ApiResponse (PageResourceQuestionTemplateResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PageResourceQuestionTemplateResource>> GetQuestionTemplatesAsyncWithHttpInfo (int? size = null, int? page = null, string order = null)
        {

            var localVarPath = "/trivia/questions/templates";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (size != null) localVarQueryParams.Add("size", Configuration.ApiClient.ParameterToString(size)); // query parameter
            if (page != null) localVarQueryParams.Add("page", Configuration.ApiClient.ParameterToString(page)); // query parameter
            if (order != null) localVarQueryParams.Add("order", Configuration.ApiClient.ParameterToString(order)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionTemplates", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PageResourceQuestionTemplateResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (PageResourceQuestionTemplateResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(PageResourceQuestionTemplateResource)));
            
        }

        /// <summary>
        /// List and search questions 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>PageResourceQuestionResource</returns>
        public PageResourceQuestionResource GetQuestions (int? size = null, int? page = null, string order = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterTag = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {
             ApiResponse<PageResourceQuestionResource> localVarResponse = GetQuestionsWithHttpInfo(size, page, order, filterSearch, filterIdset, filterCategory, filterTagset, filterTag, filterType, filterPublished, filterImportId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List and search questions 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>ApiResponse of PageResourceQuestionResource</returns>
        public ApiResponse< PageResourceQuestionResource > GetQuestionsWithHttpInfo (int? size = null, int? page = null, string order = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterTag = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {

            var localVarPath = "/trivia/questions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (size != null) localVarQueryParams.Add("size", Configuration.ApiClient.ParameterToString(size)); // query parameter
            if (page != null) localVarQueryParams.Add("page", Configuration.ApiClient.ParameterToString(page)); // query parameter
            if (order != null) localVarQueryParams.Add("order", Configuration.ApiClient.ParameterToString(order)); // query parameter
            if (filterSearch != null) localVarQueryParams.Add("filter_search", Configuration.ApiClient.ParameterToString(filterSearch)); // query parameter
            if (filterIdset != null) localVarQueryParams.Add("filter_idset", Configuration.ApiClient.ParameterToString(filterIdset)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterTagset != null) localVarQueryParams.Add("filter_tagset", Configuration.ApiClient.ParameterToString(filterTagset)); // query parameter
            if (filterTag != null) localVarQueryParams.Add("filter_tag", Configuration.ApiClient.ParameterToString(filterTag)); // query parameter
            if (filterType != null) localVarQueryParams.Add("filter_type", Configuration.ApiClient.ParameterToString(filterType)); // query parameter
            if (filterPublished != null) localVarQueryParams.Add("filter_published", Configuration.ApiClient.ParameterToString(filterPublished)); // query parameter
            if (filterImportId != null) localVarQueryParams.Add("filter_import_id", Configuration.ApiClient.ParameterToString(filterImportId)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PageResourceQuestionResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (PageResourceQuestionResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(PageResourceQuestionResource)));
            
        }

        /// <summary>
        /// List and search questions 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of PageResourceQuestionResource</returns>
        public async System.Threading.Tasks.Task<PageResourceQuestionResource> GetQuestionsAsync (int? size = null, int? page = null, string order = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterTag = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {
             ApiResponse<PageResourceQuestionResource> localVarResponse = await GetQuestionsAsyncWithHttpInfo(size, page, order, filterSearch, filterIdset, filterCategory, filterTagset, filterTag, filterType, filterPublished, filterImportId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List and search questions 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="size">The number of objects returned per page (optional, default to 25)</param>
        /// <param name="page">The number of the page returned, starting with 1 (optional, default to 1)</param>
        /// <param name="order">A comma separated list of sorting requirements in priority order, each entry matching PROPERTY_NAME:[ASC|DESC] (optional, default to id:ASC)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of ApiResponse (PageResourceQuestionResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<PageResourceQuestionResource>> GetQuestionsAsyncWithHttpInfo (int? size = null, int? page = null, string order = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterTag = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {

            var localVarPath = "/trivia/questions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (size != null) localVarQueryParams.Add("size", Configuration.ApiClient.ParameterToString(size)); // query parameter
            if (page != null) localVarQueryParams.Add("page", Configuration.ApiClient.ParameterToString(page)); // query parameter
            if (order != null) localVarQueryParams.Add("order", Configuration.ApiClient.ParameterToString(order)); // query parameter
            if (filterSearch != null) localVarQueryParams.Add("filter_search", Configuration.ApiClient.ParameterToString(filterSearch)); // query parameter
            if (filterIdset != null) localVarQueryParams.Add("filter_idset", Configuration.ApiClient.ParameterToString(filterIdset)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterTagset != null) localVarQueryParams.Add("filter_tagset", Configuration.ApiClient.ParameterToString(filterTagset)); // query parameter
            if (filterTag != null) localVarQueryParams.Add("filter_tag", Configuration.ApiClient.ParameterToString(filterTag)); // query parameter
            if (filterType != null) localVarQueryParams.Add("filter_type", Configuration.ApiClient.ParameterToString(filterType)); // query parameter
            if (filterPublished != null) localVarQueryParams.Add("filter_published", Configuration.ApiClient.ParameterToString(filterPublished)); // query parameter
            if (filterImportId != null) localVarQueryParams.Add("filter_import_id", Configuration.ApiClient.ParameterToString(filterImportId)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestions", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<PageResourceQuestionResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (PageResourceQuestionResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(PageResourceQuestionResource)));
            
        }

        /// <summary>
        /// Count questions based on filters This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <returns>long?</returns>
        public long? GetQuestionsCount (string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null)
        {
             ApiResponse<long?> localVarResponse = GetQuestionsCountWithHttpInfo(filterSearch, filterIdset, filterCategory, filterTag, filterTagset, filterType, filterPublished);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Count questions based on filters This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <returns>ApiResponse of long?</returns>
        public ApiResponse< long? > GetQuestionsCountWithHttpInfo (string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null)
        {

            var localVarPath = "/trivia/questions/count";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (filterSearch != null) localVarQueryParams.Add("filter_search", Configuration.ApiClient.ParameterToString(filterSearch)); // query parameter
            if (filterIdset != null) localVarQueryParams.Add("filter_idset", Configuration.ApiClient.ParameterToString(filterIdset)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterTag != null) localVarQueryParams.Add("filter_tag", Configuration.ApiClient.ParameterToString(filterTag)); // query parameter
            if (filterTagset != null) localVarQueryParams.Add("filter_tagset", Configuration.ApiClient.ParameterToString(filterTagset)); // query parameter
            if (filterType != null) localVarQueryParams.Add("filter_type", Configuration.ApiClient.ParameterToString(filterType)); // query parameter
            if (filterPublished != null) localVarQueryParams.Add("filter_published", Configuration.ApiClient.ParameterToString(filterPublished)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionsCount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<long?>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (long?) Configuration.ApiClient.Deserialize(localVarResponse, typeof(long?)));
            
        }

        /// <summary>
        /// Count questions based on filters This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <returns>Task of long?</returns>
        public async System.Threading.Tasks.Task<long?> GetQuestionsCountAsync (string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null)
        {
             ApiResponse<long?> localVarResponse = await GetQuestionsCountAsyncWithHttpInfo(filterSearch, filterIdset, filterCategory, filterTag, filterTagset, filterType, filterPublished);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Count questions based on filters This is also provided by the list endpoint so you don&#39;t need to call this for pagination purposes
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <returns>Task of ApiResponse (long?)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<long?>> GetQuestionsCountAsyncWithHttpInfo (string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null)
        {

            var localVarPath = "/trivia/questions/count";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (filterSearch != null) localVarQueryParams.Add("filter_search", Configuration.ApiClient.ParameterToString(filterSearch)); // query parameter
            if (filterIdset != null) localVarQueryParams.Add("filter_idset", Configuration.ApiClient.ParameterToString(filterIdset)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterTag != null) localVarQueryParams.Add("filter_tag", Configuration.ApiClient.ParameterToString(filterTag)); // query parameter
            if (filterTagset != null) localVarQueryParams.Add("filter_tagset", Configuration.ApiClient.ParameterToString(filterTagset)); // query parameter
            if (filterType != null) localVarQueryParams.Add("filter_type", Configuration.ApiClient.ParameterToString(filterType)); // query parameter
            if (filterPublished != null) localVarQueryParams.Add("filter_published", Configuration.ApiClient.ParameterToString(filterPublished)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("GetQuestionsCount", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<long?>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (long?) Configuration.ApiClient.Deserialize(localVarResponse, typeof(long?)));
            
        }

        /// <summary>
        /// Start processing an import job Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="publishNow">Whether the new questions should be published live immediately</param>
        /// <returns>ImportJobResource</returns>
        public ImportJobResource ProcessImportJob (long? id, bool? publishNow)
        {
             ApiResponse<ImportJobResource> localVarResponse = ProcessImportJobWithHttpInfo(id, publishNow);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Start processing an import job Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="publishNow">Whether the new questions should be published live immediately</param>
        /// <returns>ApiResponse of ImportJobResource</returns>
        public ApiResponse< ImportJobResource > ProcessImportJobWithHttpInfo (long? id, bool? publishNow)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->ProcessImportJob");
            // verify the required parameter 'publishNow' is set
            if (publishNow == null)
                throw new ApiException(400, "Missing required parameter 'publishNow' when calling GamificationTriviaApi->ProcessImportJob");

            var localVarPath = "/trivia/import/{id}/process";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (publishNow != null) localVarQueryParams.Add("publish_now", Configuration.ApiClient.ParameterToString(publishNow)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProcessImportJob", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ImportJobResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ImportJobResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ImportJobResource)));
            
        }

        /// <summary>
        /// Start processing an import job Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="publishNow">Whether the new questions should be published live immediately</param>
        /// <returns>Task of ImportJobResource</returns>
        public async System.Threading.Tasks.Task<ImportJobResource> ProcessImportJobAsync (long? id, bool? publishNow)
        {
             ApiResponse<ImportJobResource> localVarResponse = await ProcessImportJobAsyncWithHttpInfo(id, publishNow);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Start processing an import job Will process the CSV file and add new questions asynchronously. The status of the job must be &#39;VALID&#39;.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="publishNow">Whether the new questions should be published live immediately</param>
        /// <returns>Task of ApiResponse (ImportJobResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ImportJobResource>> ProcessImportJobAsyncWithHttpInfo (long? id, bool? publishNow)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->ProcessImportJob");
            // verify the required parameter 'publishNow' is set
            if (publishNow == null)
                throw new ApiException(400, "Missing required parameter 'publishNow' when calling GamificationTriviaApi->ProcessImportJob");

            var localVarPath = "/trivia/import/{id}/process";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (publishNow != null) localVarQueryParams.Add("publish_now", Configuration.ApiClient.ParameterToString(publishNow)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("ProcessImportJob", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ImportJobResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ImportJobResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ImportJobResource)));
            
        }

        /// <summary>
        /// Remove a tag from a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The tag to remove</param>
        /// <returns></returns>
        public void RemoveQuestionTag (string id, string tag)
        {
             RemoveQuestionTagWithHttpInfo(id, tag);
        }

        /// <summary>
        /// Remove a tag from a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The tag to remove</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> RemoveQuestionTagWithHttpInfo (string id, string tag)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->RemoveQuestionTag");
            // verify the required parameter 'tag' is set
            if (tag == null)
                throw new ApiException(400, "Missing required parameter 'tag' when calling GamificationTriviaApi->RemoveQuestionTag");

            var localVarPath = "/trivia/questions/{id}/tags/{tag}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (tag != null) localVarPathParams.Add("tag", Configuration.ApiClient.ParameterToString(tag)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveQuestionTag", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Remove a tag from a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The tag to remove</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task RemoveQuestionTagAsync (string id, string tag)
        {
             await RemoveQuestionTagAsyncWithHttpInfo(id, tag);

        }

        /// <summary>
        /// Remove a tag from a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="tag">The tag to remove</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> RemoveQuestionTagAsyncWithHttpInfo (string id, string tag)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->RemoveQuestionTag");
            // verify the required parameter 'tag' is set
            if (tag == null)
                throw new ApiException(400, "Missing required parameter 'tag' when calling GamificationTriviaApi->RemoveQuestionTag");

            var localVarPath = "/trivia/questions/{id}/tags/{tag}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (tag != null) localVarPathParams.Add("tag", Configuration.ApiClient.ParameterToString(tag)); // path parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveQuestionTag", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Remove a tag from a batch of questions ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to remove</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>int?</returns>
        public int? RemoveTagToQuestionsBatch (string tag, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {
             ApiResponse<int?> localVarResponse = RemoveTagToQuestionsBatchWithHttpInfo(tag, filterSearch, filterIdset, filterCategory, filterTag, filterTagset, filterType, filterPublished, filterImportId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Remove a tag from a batch of questions ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to remove</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>ApiResponse of int?</returns>
        public ApiResponse< int? > RemoveTagToQuestionsBatchWithHttpInfo (string tag, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {
            // verify the required parameter 'tag' is set
            if (tag == null)
                throw new ApiException(400, "Missing required parameter 'tag' when calling GamificationTriviaApi->RemoveTagToQuestionsBatch");

            var localVarPath = "/trivia/questions/tags/{tag}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (tag != null) localVarPathParams.Add("tag", Configuration.ApiClient.ParameterToString(tag)); // path parameter
            if (filterSearch != null) localVarQueryParams.Add("filter_search", Configuration.ApiClient.ParameterToString(filterSearch)); // query parameter
            if (filterIdset != null) localVarQueryParams.Add("filter_idset", Configuration.ApiClient.ParameterToString(filterIdset)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterTag != null) localVarQueryParams.Add("filter_tag", Configuration.ApiClient.ParameterToString(filterTag)); // query parameter
            if (filterTagset != null) localVarQueryParams.Add("filter_tagset", Configuration.ApiClient.ParameterToString(filterTagset)); // query parameter
            if (filterType != null) localVarQueryParams.Add("filter_type", Configuration.ApiClient.ParameterToString(filterType)); // query parameter
            if (filterPublished != null) localVarQueryParams.Add("filter_published", Configuration.ApiClient.ParameterToString(filterPublished)); // query parameter
            if (filterImportId != null) localVarQueryParams.Add("filter_import_id", Configuration.ApiClient.ParameterToString(filterImportId)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveTagToQuestionsBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<int?>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (int?) Configuration.ApiClient.Deserialize(localVarResponse, typeof(int?)));
            
        }

        /// <summary>
        /// Remove a tag from a batch of questions ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to remove</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of int?</returns>
        public async System.Threading.Tasks.Task<int?> RemoveTagToQuestionsBatchAsync (string tag, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {
             ApiResponse<int?> localVarResponse = await RemoveTagToQuestionsBatchAsyncWithHttpInfo(tag, filterSearch, filterIdset, filterCategory, filterTag, filterTagset, filterType, filterPublished, filterImportId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Remove a tag from a batch of questions ll questions that have the tag and match filters will have it removed. The returned number is the number of questions updated.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="tag">The tag to remove</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTag">Filter for questions with specified tag (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of ApiResponse (int?)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<int?>> RemoveTagToQuestionsBatchAsyncWithHttpInfo (string tag, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTag = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {
            // verify the required parameter 'tag' is set
            if (tag == null)
                throw new ApiException(400, "Missing required parameter 'tag' when calling GamificationTriviaApi->RemoveTagToQuestionsBatch");

            var localVarPath = "/trivia/questions/tags/{tag}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (tag != null) localVarPathParams.Add("tag", Configuration.ApiClient.ParameterToString(tag)); // path parameter
            if (filterSearch != null) localVarQueryParams.Add("filter_search", Configuration.ApiClient.ParameterToString(filterSearch)); // query parameter
            if (filterIdset != null) localVarQueryParams.Add("filter_idset", Configuration.ApiClient.ParameterToString(filterIdset)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterTag != null) localVarQueryParams.Add("filter_tag", Configuration.ApiClient.ParameterToString(filterTag)); // query parameter
            if (filterTagset != null) localVarQueryParams.Add("filter_tagset", Configuration.ApiClient.ParameterToString(filterTagset)); // query parameter
            if (filterType != null) localVarQueryParams.Add("filter_type", Configuration.ApiClient.ParameterToString(filterType)); // query parameter
            if (filterPublished != null) localVarQueryParams.Add("filter_published", Configuration.ApiClient.ParameterToString(filterPublished)); // query parameter
            if (filterImportId != null) localVarQueryParams.Add("filter_import_id", Configuration.ApiClient.ParameterToString(filterImportId)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.DELETE, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("RemoveTagToQuestionsBatch", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<int?>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (int?) Configuration.ApiClient.Deserialize(localVarResponse, typeof(int?)));
            
        }

        /// <summary>
        /// List and search tags by the beginning of the string For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for tags starting with the given text (optional)</param>
        /// <param name="filterCategory">Filter for tags on questions from a specific category (optional)</param>
        /// <param name="filterImportId">Filter for tags on questions from a specific import job (optional)</param>
        /// <returns>Collectionstring</returns>
        public Collectionstring SearchQuestionTags (string filterSearch = null, string filterCategory = null, long? filterImportId = null)
        {
             ApiResponse<Collectionstring> localVarResponse = SearchQuestionTagsWithHttpInfo(filterSearch, filterCategory, filterImportId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// List and search tags by the beginning of the string For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for tags starting with the given text (optional)</param>
        /// <param name="filterCategory">Filter for tags on questions from a specific category (optional)</param>
        /// <param name="filterImportId">Filter for tags on questions from a specific import job (optional)</param>
        /// <returns>ApiResponse of Collectionstring</returns>
        public ApiResponse< Collectionstring > SearchQuestionTagsWithHttpInfo (string filterSearch = null, string filterCategory = null, long? filterImportId = null)
        {

            var localVarPath = "/trivia/tags";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (filterSearch != null) localVarQueryParams.Add("filter_search", Configuration.ApiClient.ParameterToString(filterSearch)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterImportId != null) localVarQueryParams.Add("filter_import_id", Configuration.ApiClient.ParameterToString(filterImportId)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SearchQuestionTags", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Collectionstring>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Collectionstring) Configuration.ApiClient.Deserialize(localVarResponse, typeof(Collectionstring)));
            
        }

        /// <summary>
        /// List and search tags by the beginning of the string For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for tags starting with the given text (optional)</param>
        /// <param name="filterCategory">Filter for tags on questions from a specific category (optional)</param>
        /// <param name="filterImportId">Filter for tags on questions from a specific import job (optional)</param>
        /// <returns>Task of Collectionstring</returns>
        public async System.Threading.Tasks.Task<Collectionstring> SearchQuestionTagsAsync (string filterSearch = null, string filterCategory = null, long? filterImportId = null)
        {
             ApiResponse<Collectionstring> localVarResponse = await SearchQuestionTagsAsyncWithHttpInfo(filterSearch, filterCategory, filterImportId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// List and search tags by the beginning of the string For performance reasons, search &amp; category filters are mutually exclusive. If category is specified, search filter will be ignored in order to do fast matches for typeahead.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="filterSearch">Filter for tags starting with the given text (optional)</param>
        /// <param name="filterCategory">Filter for tags on questions from a specific category (optional)</param>
        /// <param name="filterImportId">Filter for tags on questions from a specific import job (optional)</param>
        /// <returns>Task of ApiResponse (Collectionstring)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Collectionstring>> SearchQuestionTagsAsyncWithHttpInfo (string filterSearch = null, string filterCategory = null, long? filterImportId = null)
        {

            var localVarPath = "/trivia/tags";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (filterSearch != null) localVarQueryParams.Add("filter_search", Configuration.ApiClient.ParameterToString(filterSearch)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterImportId != null) localVarQueryParams.Add("filter_import_id", Configuration.ApiClient.ParameterToString(filterImportId)); // query parameter

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.GET, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("SearchQuestionTags", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<Collectionstring>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (Collectionstring) Configuration.ApiClient.Deserialize(localVarResponse, typeof(Collectionstring)));
            
        }

        /// <summary>
        /// Update an import job Changes should be made before process is started for there to be any effect.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="request">The updated job (optional)</param>
        /// <returns>ImportJobResource</returns>
        public ImportJobResource UpdateImportJob (long? id, ImportJobResource request = null)
        {
             ApiResponse<ImportJobResource> localVarResponse = UpdateImportJobWithHttpInfo(id, request);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update an import job Changes should be made before process is started for there to be any effect.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="request">The updated job (optional)</param>
        /// <returns>ApiResponse of ImportJobResource</returns>
        public ApiResponse< ImportJobResource > UpdateImportJobWithHttpInfo (long? id, ImportJobResource request = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->UpdateImportJob");

            var localVarPath = "/trivia/import/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateImportJob", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ImportJobResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ImportJobResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ImportJobResource)));
            
        }

        /// <summary>
        /// Update an import job Changes should be made before process is started for there to be any effect.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="request">The updated job (optional)</param>
        /// <returns>Task of ImportJobResource</returns>
        public async System.Threading.Tasks.Task<ImportJobResource> UpdateImportJobAsync (long? id, ImportJobResource request = null)
        {
             ApiResponse<ImportJobResource> localVarResponse = await UpdateImportJobAsyncWithHttpInfo(id, request);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update an import job Changes should be made before process is started for there to be any effect.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the job</param>
        /// <param name="request">The updated job (optional)</param>
        /// <returns>Task of ApiResponse (ImportJobResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<ImportJobResource>> UpdateImportJobAsyncWithHttpInfo (long? id, ImportJobResource request = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->UpdateImportJob");

            var localVarPath = "/trivia/import/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (request != null && request.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(request); // http body (model) parameter
            }
            else
            {
                localVarPostBody = request; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateImportJob", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<ImportJobResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (ImportJobResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(ImportJobResource)));
            
        }

        /// <summary>
        /// Update a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="question">The updated question (optional)</param>
        /// <returns>QuestionResource</returns>
        public QuestionResource UpdateQuestion (string id, QuestionResource question = null)
        {
             ApiResponse<QuestionResource> localVarResponse = UpdateQuestionWithHttpInfo(id, question);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="question">The updated question (optional)</param>
        /// <returns>ApiResponse of QuestionResource</returns>
        public ApiResponse< QuestionResource > UpdateQuestionWithHttpInfo (string id, QuestionResource question = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->UpdateQuestion");

            var localVarPath = "/trivia/questions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (question != null && question.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(question); // http body (model) parameter
            }
            else
            {
                localVarPostBody = question; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateQuestion", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuestionResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (QuestionResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuestionResource)));
            
        }

        /// <summary>
        /// Update a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="question">The updated question (optional)</param>
        /// <returns>Task of QuestionResource</returns>
        public async System.Threading.Tasks.Task<QuestionResource> UpdateQuestionAsync (string id, QuestionResource question = null)
        {
             ApiResponse<QuestionResource> localVarResponse = await UpdateQuestionAsyncWithHttpInfo(id, question);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the question</param>
        /// <param name="question">The updated question (optional)</param>
        /// <returns>Task of ApiResponse (QuestionResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QuestionResource>> UpdateQuestionAsyncWithHttpInfo (string id, QuestionResource question = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->UpdateQuestion");

            var localVarPath = "/trivia/questions/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (question != null && question.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(question); // http body (model) parameter
            }
            else
            {
                localVarPostBody = question; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateQuestion", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuestionResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (QuestionResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuestionResource)));
            
        }

        /// <summary>
        /// Update an answer for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <param name="answer">The updated answer (optional)</param>
        /// <returns></returns>
        public void UpdateQuestionAnswer (string questionId, string id, AnswerResource answer = null)
        {
             UpdateQuestionAnswerWithHttpInfo(questionId, id, answer);
        }

        /// <summary>
        /// Update an answer for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <param name="answer">The updated answer (optional)</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public ApiResponse<Object> UpdateQuestionAnswerWithHttpInfo (string questionId, string id, AnswerResource answer = null)
        {
            // verify the required parameter 'questionId' is set
            if (questionId == null)
                throw new ApiException(400, "Missing required parameter 'questionId' when calling GamificationTriviaApi->UpdateQuestionAnswer");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->UpdateQuestionAnswer");

            var localVarPath = "/trivia/questions/{question_id}/answers/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (questionId != null) localVarPathParams.Add("question_id", Configuration.ApiClient.ParameterToString(questionId)); // path parameter
            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (answer != null && answer.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(answer); // http body (model) parameter
            }
            else
            {
                localVarPostBody = answer; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateQuestionAnswer", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Update an answer for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <param name="answer">The updated answer (optional)</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task UpdateQuestionAnswerAsync (string questionId, string id, AnswerResource answer = null)
        {
             await UpdateQuestionAnswerAsyncWithHttpInfo(questionId, id, answer);

        }

        /// <summary>
        /// Update an answer for a question 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="questionId">The id of the question</param>
        /// <param name="id">The id of the answer</param>
        /// <param name="answer">The updated answer (optional)</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<ApiResponse<Object>> UpdateQuestionAnswerAsyncWithHttpInfo (string questionId, string id, AnswerResource answer = null)
        {
            // verify the required parameter 'questionId' is set
            if (questionId == null)
                throw new ApiException(400, "Missing required parameter 'questionId' when calling GamificationTriviaApi->UpdateQuestionAnswer");
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->UpdateQuestionAnswer");

            var localVarPath = "/trivia/questions/{question_id}/answers/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (questionId != null) localVarPathParams.Add("question_id", Configuration.ApiClient.ParameterToString(questionId)); // path parameter
            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (answer != null && answer.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(answer); // http body (model) parameter
            }
            else
            {
                localVarPostBody = answer; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateQuestionAnswer", localVarResponse);
                if (exception != null) throw exception;
            }

            
            return new ApiResponse<Object>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                null);
        }

        /// <summary>
        /// Update a question template 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>QuestionTemplateResource</returns>
        public QuestionTemplateResource UpdateQuestionTemplate (string id, QuestionTemplateResource questionTemplateResource = null)
        {
             ApiResponse<QuestionTemplateResource> localVarResponse = UpdateQuestionTemplateWithHttpInfo(id, questionTemplateResource);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Update a question template 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>ApiResponse of QuestionTemplateResource</returns>
        public ApiResponse< QuestionTemplateResource > UpdateQuestionTemplateWithHttpInfo (string id, QuestionTemplateResource questionTemplateResource = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->UpdateQuestionTemplate");

            var localVarPath = "/trivia/questions/templates/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (questionTemplateResource != null && questionTemplateResource.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(questionTemplateResource); // http body (model) parameter
            }
            else
            {
                localVarPostBody = questionTemplateResource; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateQuestionTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuestionTemplateResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (QuestionTemplateResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuestionTemplateResource)));
            
        }

        /// <summary>
        /// Update a question template 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>Task of QuestionTemplateResource</returns>
        public async System.Threading.Tasks.Task<QuestionTemplateResource> UpdateQuestionTemplateAsync (string id, QuestionTemplateResource questionTemplateResource = null)
        {
             ApiResponse<QuestionTemplateResource> localVarResponse = await UpdateQuestionTemplateAsyncWithHttpInfo(id, questionTemplateResource);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Update a question template 
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="id">The id of the template</param>
        /// <param name="questionTemplateResource">The question template resource object (optional)</param>
        /// <returns>Task of ApiResponse (QuestionTemplateResource)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<QuestionTemplateResource>> UpdateQuestionTemplateAsyncWithHttpInfo (string id, QuestionTemplateResource questionTemplateResource = null)
        {
            // verify the required parameter 'id' is set
            if (id == null)
                throw new ApiException(400, "Missing required parameter 'id' when calling GamificationTriviaApi->UpdateQuestionTemplate");

            var localVarPath = "/trivia/questions/templates/{id}";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (id != null) localVarPathParams.Add("id", Configuration.ApiClient.ParameterToString(id)); // path parameter
            if (questionTemplateResource != null && questionTemplateResource.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(questionTemplateResource); // http body (model) parameter
            }
            else
            {
                localVarPostBody = questionTemplateResource; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateQuestionTemplate", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<QuestionTemplateResource>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (QuestionTemplateResource) Configuration.ApiClient.Deserialize(localVarResponse, typeof(QuestionTemplateResource)));
            
        }

        /// <summary>
        /// Bulk update questions Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">New values for a set of question fields (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>int?</returns>
        public int? UpdateQuestionsInBulk (QuestionResource question = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {
             ApiResponse<int?> localVarResponse = UpdateQuestionsInBulkWithHttpInfo(question, filterSearch, filterIdset, filterCategory, filterTagset, filterType, filterPublished, filterImportId);
             return localVarResponse.Data;
        }

        /// <summary>
        /// Bulk update questions Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">New values for a set of question fields (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>ApiResponse of int?</returns>
        public ApiResponse< int? > UpdateQuestionsInBulkWithHttpInfo (QuestionResource question = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {

            var localVarPath = "/trivia/questions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (filterSearch != null) localVarQueryParams.Add("filter_search", Configuration.ApiClient.ParameterToString(filterSearch)); // query parameter
            if (filterIdset != null) localVarQueryParams.Add("filter_idset", Configuration.ApiClient.ParameterToString(filterIdset)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterTagset != null) localVarQueryParams.Add("filter_tagset", Configuration.ApiClient.ParameterToString(filterTagset)); // query parameter
            if (filterType != null) localVarQueryParams.Add("filter_type", Configuration.ApiClient.ParameterToString(filterType)); // query parameter
            if (filterPublished != null) localVarQueryParams.Add("filter_published", Configuration.ApiClient.ParameterToString(filterPublished)); // query parameter
            if (filterImportId != null) localVarQueryParams.Add("filter_import_id", Configuration.ApiClient.ParameterToString(filterImportId)); // query parameter
            if (question != null && question.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(question); // http body (model) parameter
            }
            else
            {
                localVarPostBody = question; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateQuestionsInBulk", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<int?>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (int?) Configuration.ApiClient.Deserialize(localVarResponse, typeof(int?)));
            
        }

        /// <summary>
        /// Bulk update questions Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">New values for a set of question fields (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of int?</returns>
        public async System.Threading.Tasks.Task<int?> UpdateQuestionsInBulkAsync (QuestionResource question = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {
             ApiResponse<int?> localVarResponse = await UpdateQuestionsInBulkAsyncWithHttpInfo(question, filterSearch, filterIdset, filterCategory, filterTagset, filterType, filterPublished, filterImportId);
             return localVarResponse.Data;

        }

        /// <summary>
        /// Bulk update questions Will update all questions that match filters used (or all questions in system if no filters used). Body should match a question resource with only those properties you wish to set. Null values will be ignored. Returned number is how many were updated.
        /// </summary>
        /// <exception cref="com.knetikcloud.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="question">New values for a set of question fields (optional)</param>
        /// <param name="filterSearch">Filter for documents whose question, answers or tags contains provided string (optional)</param>
        /// <param name="filterIdset">Filter for documents whose id is in the comma separated list provided (optional)</param>
        /// <param name="filterCategory">Filter for questions with specified category, by id (optional)</param>
        /// <param name="filterTagset">Filter for questions with specified tags (separated by comma) (optional)</param>
        /// <param name="filterType">Filter for questions with specified type.  Allowable values: (&#39;TEXT&#39;, &#39;IMAGE&#39;, &#39;VIDEO&#39;, &#39;AUDIO&#39;) (optional)</param>
        /// <param name="filterPublished">Filter for questions currenctly published or not (optional)</param>
        /// <param name="filterImportId">Filter for questions from a specific import job (optional)</param>
        /// <returns>Task of ApiResponse (int?)</returns>
        public async System.Threading.Tasks.Task<ApiResponse<int?>> UpdateQuestionsInBulkAsyncWithHttpInfo (QuestionResource question = null, string filterSearch = null, string filterIdset = null, string filterCategory = null, string filterTagset = null, string filterType = null, bool? filterPublished = null, long? filterImportId = null)
        {

            var localVarPath = "/trivia/questions";
            var localVarPathParams = new Dictionary<String, String>();
            var localVarQueryParams = new Dictionary<String, String>();
            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);
            var localVarFormParams = new Dictionary<String, String>();
            var localVarFileParams = new Dictionary<String, FileParameter>();
            Object localVarPostBody = null;

            // to determine the Content-Type header
            String[] localVarHttpContentTypes = new String[] {
                "application/json"
            };
            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);

            // to determine the Accept header
            String[] localVarHttpHeaderAccepts = new String[] {
                "application/json"
            };
            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);
            if (localVarHttpHeaderAccept != null)
                localVarHeaderParams.Add("Accept", localVarHttpHeaderAccept);

            if (filterSearch != null) localVarQueryParams.Add("filter_search", Configuration.ApiClient.ParameterToString(filterSearch)); // query parameter
            if (filterIdset != null) localVarQueryParams.Add("filter_idset", Configuration.ApiClient.ParameterToString(filterIdset)); // query parameter
            if (filterCategory != null) localVarQueryParams.Add("filter_category", Configuration.ApiClient.ParameterToString(filterCategory)); // query parameter
            if (filterTagset != null) localVarQueryParams.Add("filter_tagset", Configuration.ApiClient.ParameterToString(filterTagset)); // query parameter
            if (filterType != null) localVarQueryParams.Add("filter_type", Configuration.ApiClient.ParameterToString(filterType)); // query parameter
            if (filterPublished != null) localVarQueryParams.Add("filter_published", Configuration.ApiClient.ParameterToString(filterPublished)); // query parameter
            if (filterImportId != null) localVarQueryParams.Add("filter_import_id", Configuration.ApiClient.ParameterToString(filterImportId)); // query parameter
            if (question != null && question.GetType() != typeof(byte[]))
            {
                localVarPostBody = Configuration.ApiClient.Serialize(question); // http body (model) parameter
            }
            else
            {
                localVarPostBody = question; // byte array
            }

            // authentication (OAuth2) required
            // oauth required
            if (!String.IsNullOrEmpty(Configuration.AccessToken))
            {
                localVarHeaderParams["Authorization"] = "Bearer " + Configuration.AccessToken;
            }

            // make the HTTP request
            IRestResponse localVarResponse = (IRestResponse) await Configuration.ApiClient.CallApiAsync(localVarPath,
                Method.PUT, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,
                localVarPathParams, localVarHttpContentType);

            int localVarStatusCode = (int) localVarResponse.StatusCode;

            if (ExceptionFactory != null)
            {
                Exception exception = ExceptionFactory("UpdateQuestionsInBulk", localVarResponse);
                if (exception != null) throw exception;
            }

            return new ApiResponse<int?>(localVarStatusCode,
                localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()),
                (int?) Configuration.ApiClient.Deserialize(localVarResponse, typeof(int?)));
            
        }

    }
}
